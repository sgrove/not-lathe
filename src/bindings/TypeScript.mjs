// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Debug from "../Debug.mjs";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import Typescript from "typescript";
import * as Typescript$1 from "typescript";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Vfs from "@typescript/vfs";

function findFnPos(ast, targetName) {
  var fnNode = {
    contents: undefined
  };
  var helper = function (node) {
    var match = fnNode.contents;
    if (match !== undefined) {
      return ;
    }
    if (!Typescript$1.isFunctionDeclaration(node)) {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
    var fnName = Belt_Option.map(node.name, (function (name) {
            return name.getText(ast);
          }));
    if (Caml_obj.caml_equal(fnName, targetName)) {
      fnNode.contents = Caml_option.some(node);
      return ;
    } else {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
  };
  Typescript$1.visitNode(ast, helper);
  return Belt_Option.map(fnNode.contents, (function (node) {
                try {
                  var startPos = Caml_array.get(node.body.statements, 0).pos;
                  return {
                          start: node.getStart(),
                          firstStatementStart: startPos - 1 | 0,
                          end: node.getEnd()
                        };
                }
                catch (exn){
                  return {
                          start: node.getStart(),
                          firstStatementStart: undefined,
                          end: node.getEnd()
                        };
                }
              }));
}

function findContainingDeclaration(ast, position) {
  return Belt_Array.getBy(ast.statements, (function (declaration) {
                var body = declaration.body;
                var parameters = declaration.parameters;
                var isFunctionDeclaration = Belt_Option.isSome(body === undefined ? undefined : Caml_option.some(body)) && Belt_Option.isSome(parameters === undefined ? undefined : Caml_option.some(parameters));
                var start = declaration.pos;
                var end = declaration.end;
                var containsPosition = start <= position && position <= end;
                if (isFunctionDeclaration && containsPosition) {
                  return true;
                } else {
                  return false;
                }
              }));
}

function findAllVariableDeclarationsInFunctions(ast) {
  return Belt_Array.concatMany(Belt_Array.map(ast.statements, (function (topLeveNode) {
                    if (!Typescript$1.isFunctionDeclaration(topLeveNode)) {
                      return [];
                    }
                    var helper = function (node) {
                      if (Typescript$1.isVariableDeclaration(node)) {
                        return [node];
                      } else {
                        return Belt_Array.concatMany(Belt_Array.map(node.getChildren(ast), helper));
                      }
                    };
                    return helper(topLeveNode);
                  })));
}

Debug.assignToWindowForDeveloperDebug("findAllVariableDeclarationsInFunctions", findAllVariableDeclarationsInFunctions);

function findVariableDeclarationAtPosition(ast, position) {
  var finalNode = {
    contents: undefined
  };
  var helper = function (node) {
    if (!Typescript$1.isVariableDeclaration(node)) {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
    var start = node.pos;
    var end = node.end;
    var containsPosition = start <= position && position <= end;
    if (containsPosition) {
      finalNode.contents = Caml_option.some(node);
      return ;
    } else {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
  };
  Typescript$1.visitNode(ast, helper);
  return finalNode.contents;
}

function findNodeAtPosition(ast, position) {
  var finalNode = {
    contents: undefined
  };
  var helper = function (node) {
    var start = node.pos;
    var end = node.end;
    var containsPosition = start <= position && position <= end;
    if (containsPosition) {
      finalNode.contents = Caml_option.some(node);
      return Belt_Array.forEach(node.getChildren(ast), helper);
    } else {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
  };
  Typescript$1.visitNode(ast, helper);
  return finalNode.contents;
}

Debug.assignToWindowForDeveloperDebug("findVariableDeclarationAtPosition", findVariableDeclarationAtPosition);

Debug.assignToWindowForDeveloperDebug("findNodeAtPosition", findNodeAtPosition);

function findPositionOfFirstLineOfContainingFunctionForPosition(ast, position) {
  return Belt_Option.flatMap(findContainingDeclaration(ast, position), (function (declarationNode) {
                try {
                  return Caml_array.get(declarationNode.body.statements, 0).pos;
                }
                catch (exn){
                  return ;
                }
              }));
}

var TypeFormatFlags = {};

function findContainingDeclaration$1(ast, position) {
  var assigmentStartAndEnd = {
    contents: undefined
  };
  var helper = function (node) {
    var match = Js_dict.get(Typescript$1.SyntaxKind, node.kind);
    if (match !== undefined) {
      switch (match) {
        case "ExpressionStatement" :
            var start = node.pos;
            var end = node.end;
            var containsPosition = start <= position && position <= end;
            if (!containsPosition) {
              return Belt_Array.forEach(node.getChildren(ast), helper);
            }
            Debug.assignToWindowForDeveloperDebug("debugNode", node);
            var name = node.expression.left.escapedText;
            assigmentStartAndEnd.contents = {
              start: start,
              end: end,
              name: name
            };
            return ;
        case "VariableDeclaration" :
            var start$1 = node.pos;
            var end$1 = node.end;
            var containsPosition$1 = start$1 <= position && position <= end$1;
            if (!containsPosition$1) {
              return Belt_Array.forEach(node.getChildren(ast), helper);
            }
            Debug.assignToWindowForDeveloperDebug("debugNode", node);
            var name$1 = node.name.escapedText;
            assigmentStartAndEnd.contents = {
              start: start$1,
              end: end$1,
              name: name$1
            };
            return ;
        default:
          
      }
    }
    return Belt_Array.forEach(node.getChildren(ast), helper);
  };
  Typescript$1.visitNode(ast, helper);
  return assigmentStartAndEnd.contents;
}

function findFunctionTypes(ast) {
  var results = {
    contents: []
  };
  Belt_Array.forEach(ast.statements, (function (node) {
          var match = Js_dict.get(Typescript$1.SyntaxKind, node.kind);
          if (match === undefined) {
            return ;
          }
          if (match !== "FunctionDeclaration") {
            return ;
          }
          var firstParamType = (node?.parameters?.[0]?.type?.getText(ast));
          var returnType = (node?.type?.getText(ast));
          var name = (node?.name?.getText(ast));
          return Belt_Option.forEach(name, (function (name) {
                        results.contents = Belt_Array.concat(results.contents, [{
                                name: name,
                                firstParamType: firstParamType,
                                returnType: returnType
                              }]);
                        
                      }));
        }));
  return Js_dict.fromArray(Belt_Array.map(results.contents, (function (fn) {
                    return [
                            fn.name,
                            fn
                          ];
                  })));
}

function findLastReturnObjectPos(ast, functionName, properyName) {
  var fnNode = {
    contents: undefined
  };
  var helper = function (node) {
    var match = fnNode.contents;
    if (match !== undefined) {
      return ;
    }
    if (!Typescript$1.isFunctionDeclaration(node)) {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
    var fnName = Belt_Option.map(node.name, (function (name) {
            return name.getText(ast);
          }));
    if (Caml_obj.caml_equal(fnName, functionName)) {
      fnNode.contents = Caml_option.some(node);
      return ;
    } else {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
  };
  Typescript$1.visitNode(ast, helper);
  return Belt_Option.flatMap(fnNode.contents, (function (node) {
                try {
                  return Belt_Option.map(Belt_Array.getBy(Belt_Array.reverse(node.body.statements), (function (statement) {
                                    var match = Js_dict.get(Typescript$1.SyntaxKind, statement.kind);
                                    if (match === "ReturnStatement") {
                                      return Belt_Option.isSome(Belt_Option.map(statement.expression, (function (expression) {
                                                        var match = Js_dict.get(Typescript$1.SyntaxKind, expression.kind);
                                                        if (match === "ObjectLiteralExpression") {
                                                          return true;
                                                        } else {
                                                          return false;
                                                        }
                                                      })));
                                    } else {
                                      return false;
                                    }
                                  })), (function (returnStatement) {
                                var expression = returnStatement.expression;
                                var property = Belt_Array.getBy(expression.properties, (function (property) {
                                        return property.name.escapedText === properyName;
                                      }));
                                return {
                                        start: returnStatement.pos,
                                        end: returnStatement.end,
                                        objectPosition: {
                                          start: expression.pos,
                                          end: expression.end
                                        },
                                        property: Belt_Option.map(property, (function (property) {
                                                return {
                                                        start: property.pos,
                                                        end: property.end,
                                                        name: properyName
                                                      };
                                              }))
                                      };
                              }));
                }
                catch (exn){
                  return ;
                }
              }));
}

function isFunctionEmpty(ast, targetName) {
  var fnNode = {
    contents: undefined
  };
  var helper = function (node) {
    var match = fnNode.contents;
    if (match !== undefined) {
      return ;
    }
    if (!Typescript$1.isFunctionDeclaration(node)) {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
    var fnName = Belt_Option.map(node.name, (function (name) {
            return name.getText(ast);
          }));
    if (Caml_obj.caml_equal(fnName, targetName)) {
      fnNode.contents = Caml_option.some(node);
      return ;
    } else {
      return Belt_Array.forEach(node.getChildren(ast), helper);
    }
  };
  Typescript$1.visitNode(ast, helper);
  return Belt_Option.map(fnNode.contents, (function (node) {
                try {
                  var statements = node.body.statements;
                  var len = statements.length;
                  if (len !== 1) {
                    if (len !== 0) {
                      return /* NotEmpty */3;
                    } else {
                      return /* Empty */0;
                    }
                  }
                  var statement = statements[0];
                  try {
                    var match = Js_dict.get(Typescript$1.SyntaxKind, statement.kind);
                    if (match === undefined) {
                      return /* NotEmpty */3;
                    }
                    if (match !== "ReturnStatement") {
                      return /* NotEmpty */3;
                    }
                    var expression = statement.expression;
                    var match$1 = Js_dict.get(Typescript$1.SyntaxKind, expression.kind);
                    if (match$1 === undefined) {
                      return /* NotEmpty */3;
                    }
                    if (match$1 !== "ObjectLiteralExpression") {
                      return /* NotEmpty */3;
                    }
                    var properties = expression.properties;
                    if (properties.length !== 0) {
                      if (Belt_Array.every(properties, (function (property) {
                                var name = property.name.getText(ast);
                                var value = property.initializer.getText(ast);
                                return name === value;
                              }))) {
                        return /* ProbablyGenerated */2;
                      } else {
                        return /* NotEmpty */3;
                      }
                    } else {
                      return /* EmptyObjectReturn */1;
                    }
                  }
                  catch (exn){
                    return /* NotEmpty */3;
                  }
                }
                catch (exn$1){
                  return /* NotEmpty */3;
                }
              }));
}

Debug.assignToWindowForDeveloperDebug("isFunctionEmpty", isFunctionEmpty);

Debug.assignToWindowForDeveloperDebug("ts", Typescript);

var $$Map = {};

function makeWithFileSystem(mainFile, onCreateFileSystem) {
  var __x = Vfs.createDefaultMapFromCDN({
        target: Typescript.ScriptTarget.ES2015
      }, "3.7.3", true, Typescript);
  return __x.then(function (fsMap) {
              onCreateFileSystem(fsMap);
              Debug.assignToWindowForDeveloperDebug("fsMap", fsMap);
              var system = Vfs.createSystem(fsMap);
              var env = Vfs.createVirtualTypeScriptEnvironment(system, [mainFile], Typescript, {});
              Debug.assignToWindowForDeveloperDebug("tsEnv", env);
              var program = env.languageService.getProgram();
              Debug.assignToWindowForDeveloperDebug("tsProgram", program);
              var typeChecker = program.getTypeChecker();
              Debug.assignToWindowForDeveloperDebug("tsTypeChecker", typeChecker);
              return Promise.resolve([
                          env,
                          program,
                          typeChecker,
                          fsMap,
                          system
                        ]);
            });
}

Debug.assignToWindowForDeveloperDebug("makeWithFileSystem", makeWithFileSystem);

var VirtualFileSystem = {
  makeWithFileSystem: makeWithFileSystem
};

function findTypeOfVariableDeclarationAtPosition(env, fileName, position) {
  var program = env.languageService.getProgram();
  var typeChecker = program.getTypeChecker();
  var ast = program.getSourceFile(fileName);
  var node = findVariableDeclarationAtPosition(ast, position);
  return Belt_Option.map(node, (function (node) {
                return [
                        node,
                        typeChecker.getTypeAtLocation(node)
                      ];
              }));
}

function printType(flagOpt, typeChecker, typeNode, node, param) {
  var flag = flagOpt !== undefined ? flagOpt : 0;
  return typeChecker.typeToString(typeNode, node, flag);
}

export {
  findFnPos ,
  findAllVariableDeclarationsInFunctions ,
  findVariableDeclarationAtPosition ,
  findNodeAtPosition ,
  findPositionOfFirstLineOfContainingFunctionForPosition ,
  TypeFormatFlags ,
  findContainingDeclaration$1 as findContainingDeclaration,
  findFunctionTypes ,
  findLastReturnObjectPos ,
  isFunctionEmpty ,
  $$Map ,
  VirtualFileSystem ,
  findTypeOfVariableDeclarationAtPosition ,
  printType ,
  
}
/*  Not a pure module */
