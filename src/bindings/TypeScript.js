// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Debug from "../Debug.js";
import * as Js_dict from "bs-platform/lib/es6/js_dict.mjs";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.mjs";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.mjs";
import * as Caml_array from "bs-platform/lib/es6/caml_array.mjs";
import * as Typescript from "typescript";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.mjs";
import * as Caml_option from "bs-platform/lib/es6/caml_option.mjs";

function findFnPos(ast, targetName) {
  var fnNode = {
    contents: undefined
  };
  var helper = function (node) {
    var match = fnNode.contents;
    if (match !== undefined) {
      return ;
    }
    if (!Typescript.isFunctionDeclaration(node)) {
      return Belt_Array.forEach(node.getChildren(), helper);
    }
    var fnName = Belt_Option.map(node.name, (function (name) {
            return name.getText(ast);
          }));
    if (Caml_obj.caml_equal(fnName, targetName)) {
      fnNode.contents = Caml_option.some(node);
      return ;
    } else {
      return Belt_Array.forEach(node.getChildren(), helper);
    }
  };
  Typescript.visitNode(ast, helper);
  return Belt_Option.map(fnNode.contents, (function (node) {
                return [
                        node.getStart(),
                        node.getEnd()
                      ];
              }));
}

function findContainingDeclaration(ast, position) {
  return Belt_Array.getBy(ast.statements, (function (declaration) {
                var body = declaration.body;
                var parameters = declaration.parameters;
                var isFunctionDeclaration = Belt_Option.isSome(body === undefined ? undefined : Caml_option.some(body)) && Belt_Option.isSome(parameters === undefined ? undefined : Caml_option.some(parameters));
                var start = declaration.pos;
                var end = declaration.end;
                var containsPosition = start <= position && position <= end;
                if (isFunctionDeclaration && containsPosition) {
                  return true;
                } else {
                  return false;
                }
              }));
}

function findPositionOfFirstLineOfContainingFunctionForPosition(ast, position) {
  return Belt_Option.flatMap(findContainingDeclaration(ast, position), (function (declarationNode) {
                try {
                  return Caml_array.get(declarationNode.body.statements, 0).pos;
                }
                catch (exn){
                  return ;
                }
              }));
}

function findContainingDeclaration$1(ast, position) {
  var assigmentStartAndEnd = {
    contents: undefined
  };
  var helper = function (node) {
    var match = Js_dict.get(Typescript.SyntaxKind, node.kind);
    if (match !== undefined) {
      switch (match) {
        case "ExpressionStatement" :
            var start = node.pos;
            var end = node.end;
            var containsPosition = start <= position && position <= end;
            if (!containsPosition) {
              return Belt_Array.forEach(node.getChildren(), helper);
            }
            Debug.assignToWindowForDeveloperDebug("debugNode", node);
            var name = node.expression.left.escapedText;
            assigmentStartAndEnd.contents = {
              start: start,
              end: end,
              name: name
            };
            return ;
        case "VariableDeclaration" :
            var start$1 = node.pos;
            var end$1 = node.end;
            var containsPosition$1 = start$1 <= position && position <= end$1;
            if (!containsPosition$1) {
              return Belt_Array.forEach(node.getChildren(), helper);
            }
            Debug.assignToWindowForDeveloperDebug("debugNode", node);
            var name$1 = node.name.escapedText;
            assigmentStartAndEnd.contents = {
              start: start$1,
              end: end$1,
              name: name$1
            };
            return ;
        default:
          
      }
    }
    return Belt_Array.forEach(node.getChildren(), helper);
  };
  Typescript.visitNode(ast, helper);
  return assigmentStartAndEnd.contents;
}

export {
  findFnPos ,
  findPositionOfFirstLineOfContainingFunctionForPosition ,
  findContainingDeclaration$1 as findContainingDeclaration,
  
}
/* typescript Not a pure module */
