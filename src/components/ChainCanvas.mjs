// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Comps from "./Comps.mjs";
import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as NodeLabel from "./NodeLabel.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";
import FragmentNodeJs from "./FragmentNode.js";
import * as Js_null_undefined from "rescript/lib/es6/js_null_undefined.js";
import * as Hooks from "react-relay/hooks";
import * as ReactFlowRenderer from "react-flow-renderer";
import ReactFlowRenderer$1 from "react-flow-renderer";
import * as RescriptRelay_Internal from "rescript-relay/src/RescriptRelay_Internal.mjs";
import * as ChainCanvas_oneGraphAppPackageChain_graphql from "../__generated__/ChainCanvas_oneGraphAppPackageChain_graphql.mjs";

function use(fRef) {
  var data = Hooks.useFragment(ChainCanvas_oneGraphAppPackageChain_graphql.node, fRef);
  return RescriptRelay_Internal.internal_useConvertedValue(ChainCanvas_oneGraphAppPackageChain_graphql.Internal.convertFragment, data);
}

function useOpt(opt_fRef) {
  var fr = opt_fRef !== undefined ? Caml_option.some(Caml_option.valFromOption(opt_fRef)) : undefined;
  var nullableFragmentData = Hooks.useFragment(ChainCanvas_oneGraphAppPackageChain_graphql.node, fr !== undefined ? Js_null_undefined.fromOption(Caml_option.some(Caml_option.valFromOption(fr))) : null);
  var data = (nullableFragmentData == null) ? undefined : Caml_option.some(nullableFragmentData);
  return RescriptRelay_Internal.internal_useConvertedValue((function (rawFragment) {
                if (rawFragment !== undefined) {
                  return ChainCanvas_oneGraphAppPackageChain_graphql.Internal.convertFragment(rawFragment);
                }
                
              }), data);
}

var OneGraphAppPackageChainFragment = {
  Types: undefined,
  use: use,
  useOpt: useOpt
};

var make = FragmentNodeJs;

var FragmentNodeComponent = {
  make: make
};

function emptyGraphLevel(level) {
  return {
          nodeCount: 0,
          width: 0,
          nodes: [],
          level: level
        };
}

function diagramFromApi(actions, onEditAction) {
  var nodeStyle = {
    width: "unset"
  };
  var fragmentNodes = Belt_Array.mapWithIndex(Belt_SortArray.stableSortBy(Belt_Array.keep(actions, (function (action) {
                  return false;
                })), (function (a, b) {
              return a.name.localeCompare(b.name) | 0;
            })), (function (idx, block) {
          var nodeTitleWidth = block.name.length * 7.2;
          var x = 300 - nodeTitleWidth - 105;
          return {
                  id: block.id,
                  type: "fragment",
                  data: {
                    label: "Hi there!"
                  },
                  position: {
                    x: x,
                    y: 50 * idx + 10 + 30
                  },
                  draggable: false,
                  connectable: false,
                  className: "node-label",
                  style: nodeStyle
                };
        }));
  var match = fragmentNodes.length;
  var fragmentLabelNode = match !== 0 ? [{
        id: "fragmentColumnLabel",
        type: "fragment",
        data: {
          label: "Reusable Fragments"
        },
        position: {
          x: 5,
          y: 10
        },
        draggable: false,
        connectable: false,
        style: {
          width: "unset"
        }
      }] : [];
  var operationBlocks = Belt_Array.keep(actions, (function (action) {
          return true;
        }));
  console.log("operationBlocks: ", operationBlocks);
  var levels = {};
  var graphLevels = {};
  var findReqLevel = function (action) {
    var level = Js_dict.get(levels, action.id);
    if (level !== undefined) {
      return level;
    }
    var highestDependency = Belt_Array.reduce(action.upstreamActionIds, -2, (function (level, nextId) {
            return Belt_Option.getWithDefault(Belt_Option.flatMap(Belt_Array.getBy(actions, (function (actionDependency) {
                                  return actionDependency.id === nextId;
                                })), (function (actionDependency) {
                              if (actionDependency.id === action.id) {
                                return ;
                              }
                              var dependencyLevel = findReqLevel(actionDependency);
                              levels[nextId] = dependencyLevel;
                              return Math.max(level, dependencyLevel);
                            })), level);
          }));
    var requestLevel = highestDependency + 1 | 0;
    var nodeTitleWidth = action.name.length * 7.2;
    var requestWidth = nodeTitleWidth + 105 + 10;
    var graphLevel = Belt_Option.getWithDefault(Js_dict.get(graphLevels, String(requestLevel)), emptyGraphLevel(requestLevel));
    var graphNode_left = graphLevel.width;
    var graphNode = {
      action: action,
      level: requestLevel,
      left: graphNode_left
    };
    var newGraphLevel_nodeCount = graphLevel.nodeCount + 1 | 0;
    var newGraphLevel_width = graphLevel.width + requestWidth;
    var newGraphLevel_nodes = Belt_Array.concat(graphLevel.nodes, [graphNode]);
    var newGraphLevel_level = graphLevel.level;
    var newGraphLevel = {
      nodeCount: newGraphLevel_nodeCount,
      width: newGraphLevel_width,
      nodes: newGraphLevel_nodes,
      level: newGraphLevel_level
    };
    graphLevels[String(requestLevel)] = newGraphLevel;
    return requestLevel;
  };
  Belt_Array.forEach(operationBlocks, (function (action) {
          var level = findReqLevel(action);
          console.log("Req level for action: ", action, level);
          levels[action.id] = level;
          
        }));
  console.log("Graph Levels: ", graphLevels);
  var totalWidth = Belt_Array.reduce(Js_dict.values(graphLevels), 0, (function (highest, next) {
          if (next.width > highest) {
            return next.width;
          } else {
            return highest;
          }
        }));
  var operationNodes = Belt_Array.concatMany(Belt_Array.map(Belt_SortArray.stableSortBy(Js_dict.values(graphLevels), (function (a, b) {
                  return a.level - b.level | 0;
                })), (function (graphLevel) {
              return Belt_Array.map(graphLevel.nodes, (function (node) {
                            var action = node.action;
                            var level = node.level;
                            var halfWidth = totalWidth / 2;
                            var furthestLeft = halfWidth - graphLevel.width / 2;
                            var x = furthestLeft + node.left;
                            return {
                                    id: action.id,
                                    type: "default",
                                    data: {
                                      label: React.createElement(NodeLabel.make, {
                                            actionRef: action.fragmentRefs,
                                            onEditAction: onEditAction,
                                            onDragStart: (function (param, param$1, param$2) {
                                                
                                              }),
                                            onPotentialVariableSourceConnect: (function (param) {
                                                
                                              })
                                          })
                                    },
                                    position: {
                                      x: x,
                                      y: 100 + (50 + 10.0) * level
                                    },
                                    draggable: true,
                                    connectable: true,
                                    className: "node-label",
                                    style: nodeStyle
                                  };
                          }));
            })));
  var actionEdge = Belt_Array.concatMany(Belt_Array.map(actions, (function (action) {
              var target = action.id;
              return Belt_Array.keepMap(action.upstreamActionIds, (function (actionId) {
                            var reifiedAction = Belt_Array.getBy(actions, (function (subAction) {
                                    return subAction.id === actionId;
                                  }));
                            return Belt_Option.map(reifiedAction, (function (actionDependency) {
                                          var source = actionDependency.id;
                                          var id = source + "-" + target;
                                          return {
                                                  id: id,
                                                  source: source,
                                                  target: target
                                                };
                                        }));
                          }));
            })));
  var match$1 = Belt_Array.reduce(Belt_Array.concat(actionEdge, []), [
        undefined,
        []
      ], (function (param, edge) {
          var edges = param[1];
          var distinct = param[0];
          if (Belt_SetString.has(distinct, edge.id)) {
            return [
                    distinct,
                    edges
                  ];
          } else {
            return [
                    Belt_SetString.add(distinct, edge.id),
                    Belt_Array.concat(edges, [edge])
                  ];
          }
        }));
  var edges = Belt_Array.map(match$1[1], (function (param) {
          return {
                  id: param.id,
                  source: param.source,
                  target: param.target,
                  style: {
                    stroke: "rgb(78,160,23)",
                    strokeWidth: "2px"
                  },
                  animated: true,
                  type: "step"
                };
        }));
  var nodes = Belt_Array.concat(fragmentNodes, operationNodes);
  var elements = Belt_Array.concatMany([
        nodes,
        edges,
        fragmentLabelNode
      ]);
  return {
          nodes: nodes,
          edges: edges,
          elements: elements
        };
}

function ChainCanvas(Props) {
  var chainRef = Props.chainRef;
  var onActionInspected = Props.onActionInspected;
  var onEditAction = Props.onEditAction;
  var chain = use(chainRef);
  var diagram = diagramFromApi(chain.actions, onEditAction);
  return React.createElement(ReactFlowRenderer$1, {
              elements: diagram.elements,
              style: {
                borderColor: Comps.colors["gray-10"],
                borderStyle: "solid",
                borderWidth: "1px"
              },
              onElementClick: (function (param, node) {
                  return Curry._1(onActionInspected, node.id);
                }),
              onElementsRemove: (function (elements) {
                  
                }),
              connectionLineType: "smoothstep",
              onPaneClick: (function (param) {
                  
                }),
              onConnect: (function (info) {
                  var source = info.source;
                  var target = info.target;
                  var sourceRequest = Belt_Array.getBy(chain.actions, (function (action) {
                          return action.id === source;
                        }));
                  var targetRequest = Belt_Array.getBy(chain.actions, (function (action) {
                          return action.id === target;
                        }));
                  if (sourceRequest !== undefined && targetRequest !== undefined) {
                    return ;
                  } else {
                    console.warn("Couldn't find source or target request to connect");
                    return ;
                  }
                }),
              zoomOnScroll: false,
              panOnScroll: true,
              onNodeContextMenu: (function (_event, _node) {
                  
                }),
              onPaneContextMenu: (function ($$event) {
                  
                }),
              children: null,
              nodeTypes: {
                fragment: make
              }
            }, React.createElement(ReactFlowRenderer.Controls, {
                  showZoom: false,
                  showFitView: true,
                  showInteractive: false
                }), React.createElement(ReactFlowRenderer.Background, {
                  variant: "lines",
                  gap: 20,
                  size: 1,
                  color: Comps.colors["gray-1"],
                  style: {
                    backgroundColor: "rgb(31, 33, 37)"
                  }
                }));
}

var make$1 = ChainCanvas;

export {
  OneGraphAppPackageChainFragment ,
  FragmentNodeComponent ,
  emptyGraphLevel ,
  diagramFromApi ,
  make$1 as make,
  
}
/* make Not a pure module */
