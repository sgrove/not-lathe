// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Comps from "./Comps.mjs";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Icons from "../Icons.mjs";
import * as React from "react";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as NodeLabel from "./NodeLabel.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";
import FragmentNodeJs from "./FragmentNode.js";
import * as Js_null_undefined from "rescript/lib/es6/js_null_undefined.js";
import * as Hooks from "react-relay/hooks";
import ReactFlowRenderer from "react-flow-renderer";
import * as ReactFlowRenderer$1 from "react-flow-renderer";
import MouseCursorNodeJs from "./MouseCursorNode.js";
import * as CollaborationContext from "./CollaborationContext.mjs";
import * as RescriptRelay_Internal from "rescript-relay/src/RescriptRelay_Internal.mjs";
import FlowRemoteConnectorJs from "./FlowRemoteConnector.js";
import * as ChainCanvas_chain_graphql from "../__generated__/ChainCanvas_chain_graphql.mjs";

function use(fRef) {
  var data = Hooks.useFragment(ChainCanvas_chain_graphql.node, fRef);
  return RescriptRelay_Internal.internal_useConvertedValue(ChainCanvas_chain_graphql.Internal.convertFragment, data);
}

function useOpt(opt_fRef) {
  var fr = opt_fRef !== undefined ? Caml_option.some(Caml_option.valFromOption(opt_fRef)) : undefined;
  var nullableFragmentData = Hooks.useFragment(ChainCanvas_chain_graphql.node, fr !== undefined ? Js_null_undefined.fromOption(Caml_option.some(Caml_option.valFromOption(fr))) : null);
  var data = (nullableFragmentData == null) ? undefined : Caml_option.some(nullableFragmentData);
  return RescriptRelay_Internal.internal_useConvertedValue((function (rawFragment) {
                if (rawFragment !== undefined) {
                  return ChainCanvas_chain_graphql.Internal.convertFragment(rawFragment);
                }
                
              }), data);
}

var Fragment = {
  Types: undefined,
  use: use,
  useOpt: useOpt
};

var make = FragmentNodeJs;

var FragmentNodeComponent = {
  make: make
};

var make$1 = MouseCursorNodeJs;

var MouseCursorNodeComponent = {
  make: make$1
};

var make$2 = FlowRemoteConnectorJs;

var FlowRemoteConnector = {
  make: make$2
};

function emptyGraphLevel(level) {
  return {
          nodeCount: 0,
          width: 0,
          nodes: [],
          level: level
        };
}

function diagramFromApi(actions, onEditAction, sharedBlockPositions) {
  var nodeStyle = {
    width: "unset"
  };
  var fragmentNodes = Belt_Array.mapWithIndex(Belt_SortArray.stableSortBy(Belt_Array.keep(actions, (function (action) {
                  return action.graphqlOperationKind === "FRAGMENT";
                })), (function (a, b) {
              return a.name.localeCompare(b.name) | 0;
            })), (function (idx, block) {
          var nodeTitleWidth = block.name.length * 7.2;
          var x = 300 - nodeTitleWidth - 105;
          return {
                  id: block.id,
                  type: "fragment",
                  data: {
                    label: "Hi there!"
                  },
                  position: {
                    x: x,
                    y: 50 * idx + 10 + 30
                  },
                  draggable: false,
                  connectable: false,
                  className: "node-label",
                  style: nodeStyle
                };
        }));
  var match = fragmentNodes.length;
  var fragmentLabelNode = match !== 0 ? [{
        id: "fragmentColumnLabel",
        type: "fragment",
        data: {
          label: "Reusable Fragments"
        },
        position: {
          x: 5,
          y: 10
        },
        draggable: false,
        connectable: false,
        style: {
          width: "unset"
        }
      }] : [];
  var operationBlocks = Belt_Array.keep(actions, (function (action) {
          return action.graphqlOperationKind !== "FRAGMENT";
        }));
  var levels = {};
  var graphLevels = {};
  var findReqLevel = function (action) {
    var level = Js_dict.get(levels, action.id);
    if (level !== undefined) {
      return level;
    }
    var highestDependency = Belt_Array.reduce(action.upstreamActionIds, -2, (function (level, nextId) {
            return Belt_Option.getWithDefault(Belt_Option.flatMap(Belt_Array.getBy(actions, (function (actionDependency) {
                                  return actionDependency.id === nextId;
                                })), (function (actionDependency) {
                              if (actionDependency.id === action.id) {
                                return ;
                              }
                              var dependencyLevel = findReqLevel(actionDependency);
                              levels[nextId] = dependencyLevel;
                              return Math.max(level, dependencyLevel);
                            })), level);
          }));
    var requestLevel = highestDependency + 1 | 0;
    var nodeTitleWidth = action.name.length * 7.2;
    var requestWidth = nodeTitleWidth + 105 + 10;
    var graphLevel = Belt_Option.getWithDefault(Js_dict.get(graphLevels, String(requestLevel)), emptyGraphLevel(requestLevel));
    var graphNode_left = graphLevel.width;
    var graphNode = {
      action: action,
      level: requestLevel,
      left: graphNode_left
    };
    var newGraphLevel_nodeCount = graphLevel.nodeCount + 1 | 0;
    var newGraphLevel_width = graphLevel.width + requestWidth;
    var newGraphLevel_nodes = Belt_Array.concat(graphLevel.nodes, [graphNode]);
    var newGraphLevel_level = graphLevel.level;
    var newGraphLevel = {
      nodeCount: newGraphLevel_nodeCount,
      width: newGraphLevel_width,
      nodes: newGraphLevel_nodes,
      level: newGraphLevel_level
    };
    graphLevels[String(requestLevel)] = newGraphLevel;
    return requestLevel;
  };
  Belt_Array.forEach(operationBlocks, (function (action) {
          var level = findReqLevel(action);
          levels[action.id] = level;
          
        }));
  var totalWidth = Belt_Array.reduce(Js_dict.values(graphLevels), 0, (function (highest, next) {
          if (next.width > highest) {
            return next.width;
          } else {
            return highest;
          }
        }));
  var operationNodes = Belt_Array.concatMany(Belt_Array.map(Belt_SortArray.stableSortBy(Js_dict.values(graphLevels), (function (a, b) {
                  return a.level - b.level | 0;
                })), (function (graphLevel) {
              return Belt_Array.map(graphLevel.nodes, (function (node) {
                            var action = node.action;
                            var level = node.level;
                            var halfWidth = totalWidth / 2;
                            var furthestLeft = halfWidth - graphLevel.width / 2;
                            var x = furthestLeft + node.left;
                            var existingPosition = Belt_Option.flatMap(sharedBlockPositions, (function (positions) {
                                    return Caml_option.undefined_to_opt(positions.get(action.id));
                                  }));
                            var position = Belt_Option.getWithDefault(existingPosition, {
                                  x: x,
                                  y: 100 + (50 + 10.0) * level
                                });
                            return {
                                    id: action.id,
                                    type: "default",
                                    data: {
                                      label: React.createElement(NodeLabel.make, {
                                            actionRef: action.fragmentRefs,
                                            onEditAction: onEditAction
                                          })
                                    },
                                    position: position,
                                    draggable: true,
                                    connectable: true,
                                    className: "node-label",
                                    style: nodeStyle
                                  };
                          }));
            })));
  var actionEdge = Belt_Array.concatMany(Belt_Array.map(actions, (function (action) {
              var target = action.id;
              return Belt_Array.keepMap(action.upstreamActionIds, (function (actionId) {
                            var reifiedAction = Belt_Array.getBy(actions, (function (subAction) {
                                    return subAction.id === actionId;
                                  }));
                            return Belt_Option.map(reifiedAction, (function (actionDependency) {
                                          var source = actionDependency.id;
                                          var id = source + "-" + target;
                                          return {
                                                  id: id,
                                                  source: source,
                                                  target: target
                                                };
                                        }));
                          }));
            })));
  var match$1 = Belt_Array.reduce(Belt_Array.concat(actionEdge, []), [
        undefined,
        []
      ], (function (param, edge) {
          var edges = param[1];
          var distinct = param[0];
          if (Belt_SetString.has(distinct, edge.id)) {
            return [
                    distinct,
                    edges
                  ];
          } else {
            return [
                    Belt_SetString.add(distinct, edge.id),
                    Belt_Array.concat(edges, [edge])
                  ];
          }
        }));
  var edges = Belt_Array.map(match$1[1], (function (param) {
          return {
                  id: param.id,
                  source: param.source,
                  target: param.target,
                  style: {
                    stroke: "rgb(78,160,23)",
                    strokeWidth: "2px"
                  },
                  animated: true,
                  type: "step"
                };
        }));
  var nodes = Belt_Array.concat(fragmentNodes, operationNodes);
  var elements = Belt_Array.concatMany([
        nodes,
        edges,
        fragmentLabelNode
      ]);
  return {
          nodes: nodes,
          edges: edges,
          elements: elements
        };
}

function ChainCanvas(Props) {
  var chainRef = Props.chainRef;
  var onActionInspected = Props.onActionInspected;
  var onEditAction = Props.onEditAction;
  var onSelectionCleared = Props.onSelectionCleared;
  var onConnect = Props.onConnect;
  var chain = use(chainRef);
  var collaborationContext = React.useContext(CollaborationContext.context);
  var sharedBlockPositions = Curry._2(collaborationContext.getSharedMap, chain.id, "positions");
  var diagram = diagramFromApi(chain.actions, onEditAction, sharedBlockPositions);
  var match = ReactFlowRenderer$1.useZoomPanHelper();
  var project = match.project;
  var connectorLines = [];
  var mouseCursors = [];
  Belt_Option.forEach(Curry._1(collaborationContext.getSharedChannelState, chain.id), (function (param) {
          var localClientId = param[0];
          var entries = Array.from(param[1].entries());
          return Belt_Array.forEach(entries, (function (param) {
                        var presence = param[1];
                        var clientId = param[0];
                        var match = Caml_obj.caml_equal(clientId, localClientId);
                        var match$1 = presence.position;
                        var match$2 = presence.connectSourceActionId;
                        if (match) {
                          return ;
                        }
                        if (match$1 === undefined) {
                          return ;
                        }
                        var mouseElementId = "cursor-" + clientId;
                        var mouseCursor = {
                          id: mouseElementId,
                          type: "mouseCursor",
                          data: {
                            label: React.createElement("div", {
                                  className: "presence-mouse",
                                  style: {
                                    color: presence.color
                                  }
                                }, React.createElement("div", undefined, React.createElement(Icons.MouseCursor.make, {
                                          className: "inline-block",
                                          color: presence.color,
                                          width: "16px",
                                          height: "16px"
                                        }), Belt_Option.mapWithDefault(Caml_option.undefined_to_opt(presence.audioVolumeLevel), null, (function (level) {
                                            return React.createElement(Icons.Volume.Auto.make, {
                                                        className: "inline-block",
                                                        color: presence.color,
                                                        width: "16px",
                                                        height: "16px",
                                                        level: level
                                                      });
                                          }))), React.createElement("div", {
                                      className: "pl-2"
                                    }, React.createElement("span", {
                                          className: "pl-2"
                                        }, presence.name)))
                          },
                          position: {
                            x: match$1.x,
                            y: match$1.y
                          },
                          draggable: false,
                          selectable: false,
                          connectable: true,
                          className: "node-label"
                        };
                        Belt_Option.forEach(match$2 === undefined ? undefined : Caml_option.some(match$2), (function (connectSourceActionId) {
                                var connectorLine = {
                                  id: "edges-connect-line-" + clientId,
                                  source: connectSourceActionId,
                                  target: mouseElementId,
                                  style: {
                                    stroke: presence.color,
                                    strokeWidth: "3px"
                                  },
                                  type: "straight"
                                };
                                connectorLines.push(connectorLine);
                                
                              }));
                        mouseCursors.push(mouseCursor);
                        
                      }));
        }));
  var elements = Belt_Array.concatMany([
        diagram.elements,
        connectorLines,
        mouseCursors
      ]);
  return React.createElement("div", {
              style: {
                height: "100%",
                width: "100%"
              },
              onMouseMove: (function ($$event) {
                  var boundingRect = $$event.currentTarget.getBoundingClientRect();
                  var left = boundingRect.left;
                  var top = boundingRect.top;
                  var screenPosition_x = $$event.clientX - left | 0;
                  var screenPosition_y = $$event.clientY - top | 0;
                  var screenPosition = {
                    x: screenPosition_x,
                    y: screenPosition_y
                  };
                  var projectedPosition = project(screenPosition);
                  return Curry._2(collaborationContext.updateLocalPosition, chain.id, projectedPosition);
                })
            }, React.createElement(ReactFlowRenderer, {
                  elements: elements,
                  style: {
                    borderColor: Comps.colors["gray-10"],
                    borderStyle: "solid",
                    borderWidth: "1px"
                  },
                  onElementClick: (function (param, node) {
                      return Curry._1(onActionInspected, node.id);
                    }),
                  connectionLineType: "smoothstep",
                  onPaneClick: (function (param) {
                      return Curry._1(onSelectionCleared, undefined);
                    }),
                  onNodeDrag: (function (_event, node) {
                      if (sharedBlockPositions === undefined) {
                        return ;
                      }
                      var id = node.id;
                      var position = node.position;
                      Caml_option.valFromOption(sharedBlockPositions).set(id, position);
                      
                    }),
                  onConnect: (function (info) {
                      var sourceAction = Belt_Array.getBy(chain.actions, (function (action) {
                              return action.id === info.source;
                            }));
                      var targetAction = Belt_Array.getBy(chain.actions, (function (action) {
                              return action.id === info.target;
                            }));
                      if (sourceAction !== undefined && targetAction !== undefined) {
                        return Curry._2(onConnect, sourceAction.id, targetAction.id);
                      } else {
                        console.warn("Couldn't find source or target request to connect");
                        return ;
                      }
                    }),
                  onConnectStart: (function ($$event, node) {
                      var boundingRect = $$event.currentTarget.getBoundingClientRect();
                      var left = boundingRect.left;
                      var top = boundingRect.top;
                      var screenPosition_x = $$event.clientX - left | 0;
                      var screenPosition_y = $$event.clientY - top | 0;
                      var screenPosition = {
                        x: screenPosition_x,
                        y: screenPosition_y
                      };
                      console.log("Connect start: ", $$event, node);
                      project(screenPosition);
                      return Curry._2(collaborationContext.updateConnectSourceActionId, chain.id, node.nodeId);
                    }),
                  onConnectEnd: (function (_event, _node) {
                      return Curry._2(collaborationContext.updateConnectSourceActionId, chain.id, undefined);
                    }),
                  zoomOnScroll: false,
                  panOnScroll: true,
                  onNodeContextMenu: (function (_event, _node) {
                      
                    }),
                  onPaneContextMenu: (function ($$event) {
                      $$event.preventDefault();
                      
                    }),
                  children: null,
                  nodeTypes: {
                    fragment: make,
                    mouseCursor: make$1
                  },
                  edgeTypes: {
                    remote: make$2
                  }
                }, React.createElement(ReactFlowRenderer$1.Controls, {
                      showZoom: false,
                      showFitView: true,
                      showInteractive: false
                    }), React.createElement(ReactFlowRenderer$1.Background, {
                      variant: "lines",
                      gap: 20,
                      size: 1,
                      color: Comps.colors["gray-1"],
                      style: {
                        backgroundColor: "rgb(31, 33, 37)"
                      }
                    })));
}

var make$3 = ChainCanvas;

export {
  Fragment ,
  FragmentNodeComponent ,
  MouseCursorNodeComponent ,
  FlowRemoteConnector ,
  emptyGraphLevel ,
  diagramFromApi ,
  make$3 as make,
  
}
/* make Not a pure module */
