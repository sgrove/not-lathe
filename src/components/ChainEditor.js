// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "../Card.js";
import * as Help from "./Help.js";
import * as Uuid from "uuid";
import * as Acorn from "../bindings/Acorn.js";
import * as Chain from "../Chain.js";
import * as Comps from "./Comps.js";
import * as Curry from "bs-platform/lib/es6/curry.mjs";
import * as Debug from "../Debug.js";
import * as Hooks from "../Hooks.js";
import * as Icons from "../Icons.js";
import * as Utils from "../Utils.js";
import * as Acorn$1 from "acorn";
import * as React from "react";
import * as $$String from "bs-platform/lib/es6/string.mjs";
import * as Js_dict from "bs-platform/lib/es6/js_dict.mjs";
import * as Graphql from "graphql";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.mjs";
import * as Prettier from "prettier";
import * as GraphQLJs from "../bindings/GraphQLJs.js";
import * as Inspector from "./Inspector.js";
import * as $$Navigator from "../bindings/Navigator.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.mjs";
import * as Caml_array from "bs-platform/lib/es6/caml_array.mjs";
import * as OneGraphRe from "../OneGraphRe.js";
import * as TypeScript from "../bindings/TypeScript.js";
import * as Typescript from "typescript";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.mjs";
import * as Belt_Result from "bs-platform/lib/es6/belt_Result.mjs";
import * as BlockEditor from "./BlockEditor.js";
import * as BlockSearch from "./BlockSearch.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.mjs";
import * as GraphQLUtils from "../bindings/GraphQLUtils.js";
import * as OneGraphAuth from "../bindings/OneGraphAuth.js";
import * as ScriptEditor from "./ScriptEditor.js";
import * as Belt_SetString from "bs-platform/lib/es6/belt_SetString.mjs";
import * as Belt_SortArray from "bs-platform/lib/es6/belt_SortArray.mjs";
import ReactDraggable from "react-draggable";
import FragmentNodeJs from "./FragmentNode.js";
import * as ConnectionContext from "./ConnectionContext.js";
import * as RequestValueCache from "../RequestValueCache.js";
import * as AudioStreamContext from "./AudioStreamContext.js";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.mjs";
import * as ReactHotkeysHook from "react-hotkeys-hook";
import ReactResizePanel from "react-resize-panel";
import * as ReactFlowRenderer from "react-flow-renderer";
import ReactFlowRenderer$1 from "react-flow-renderer";
import ParserBabel from "prettier/parser-babel";
import * as QuickjsEmscripten from "@dww/quickjs-emscripten";
import * as RecordStore from "@insightdotjs-hackers/platform/lib/core/RecordStore";

var SimpleTooltip = {};

var make = FragmentNodeJs;

var FragmentNodeComponent = {
  make: make
};

function makeBlankBlock(kind) {
  var match = kind === "mutation" ? [
      /* Mutation */1,
      "mutation Untitled { __typename }"
    ] : (
      kind === "compute" ? [
          /* Compute */4,
          "# Fields on ComputeType will turn into variables for you to compute\n# based on other blocks or user input\ntype ComputeType {\n  name: String!\n}"
        ] : (
          kind === "subscription" ? [
              /* Subscription */2,
              "subscription Untitled { __typename }"
            ] : [
              /* Query */0,
              "query Untitled { __typename }"
            ]
        )
    );
  return {
          id: Uuid.v4(),
          title: "Untitled",
          description: "TODO",
          body: match[1],
          kind: match[0],
          contributedBy: undefined,
          services: []
        };
}

function namedGraphQLScalarTypeScriptType(typ) {
  switch (typ) {
    case "Float" :
    case "Int" :
        return "number";
    case "JSON" :
        return "any";
    case "ID" :
    case "String" :
        return "string";
    default:
      return typ;
  }
}

function compileChain(schema, chain) {
  try {
    var compiled = Chain.compileAsObj(chain);
    var parsedOperationDoc = Graphql.parse(compiled.operationDoc);
    var mockedVariables = GraphQLJs.Mock.mockOperationDocVariables(schema, parsedOperationDoc);
    return {
            compiled: compiled,
            variables: mockedVariables
          };
  }
  catch (_ex){
    return ;
  }
}

var context = React.createContext(undefined);

var provider = context.Provider;

function ChainEditor$InspectedContextProvider(Props) {
  var value = Props.value;
  var children = Props.children;
  return React.createElement(provider, {
              value: value,
              children: children
            });
}

var InspectedContextProvider = {
  context: context,
  provider: provider,
  make: ChainEditor$InspectedContextProvider
};

var empty = RequestValueCache.make(undefined);

var context$1 = React.createContext(empty);

var provider$1 = context$1.Provider;

function ChainEditor$RequestValueCacheProvider(Props) {
  var value = Props.value;
  var children = Props.children;
  return React.createElement(provider$1, {
              value: value,
              children: children
            });
}

var RequestValueCacheProvider = {
  empty: empty,
  context: context$1,
  provider: provider$1,
  make: ChainEditor$RequestValueCacheProvider
};

function ChainEditor$NodeLabel(Props) {
  var request = Props.request;
  var block = Props.block;
  var onEditBlock = Props.onEditBlock;
  var onDragStart = Props.onDragStart;
  var onPotentialVariableSourceConnect = Props.onPotentialVariableSourceConnect;
  var services = Belt_Array.keepMap(block.services, (function (service) {
          return Belt_Option.map(Utils.serviceImageUrl(undefined, undefined, service), (function (param) {
                        var friendlyServiceName = param[1];
                        return React.createElement("img", {
                                    key: friendlyServiceName,
                                    className: "shadow-lg rounded-full",
                                    style: {
                                      pointerEvents: "none"
                                    },
                                    title: friendlyServiceName,
                                    alt: friendlyServiceName,
                                    height: "16px",
                                    src: param[0],
                                    width: "16px"
                                  });
                      }));
        }));
  var connectionDrag = React.useContext(ConnectionContext.context);
  var requestValueCache = React.useContext(context$1);
  var match = React.useState(function () {
        return false;
      });
  var setMouseHover = match[1];
  var mouseHover = match[0];
  var result = Belt_Option.flatMap(request, (function (request) {
          return RequestValueCache.get(requestValueCache, request.id);
        }));
  var dataState = result !== undefined ? (
      Belt_Option.mapWithDefault(Caml_option.undefined_to_opt(result.errors), 0, (function (prim) {
              return prim.length;
            })) > 0 ? "error" : "data"
    ) : "mocked";
  var indicatorClass = dataState === "data" ? "data-indicator" : (
      dataState === "error" ? "error-indicator" : "mocked-indicator"
    );
  var domRef = React.useRef(null);
  var match$1 = block.kind;
  var className;
  var exit = 0;
  var exit$1 = 0;
  var exit$2 = 0;
  var exit$3 = 0;
  if (typeof connectionDrag === "number") {
    className = "";
  } else {
    switch (connectionDrag.TAG | 0) {
      case /* StartedTarget */1 :
          var match$2 = connectionDrag.target;
          if (match$1 !== 3) {
            switch (match$2.TAG | 0) {
              case /* Variable */0 :
                  className = Caml_obj.caml_equal(match$2._0.targetRequest, request) ? " node-drop drag-source no-drop" : (
                      mouseHover ? " node-drop drag-target drop-ready" : " node-drop drag-target"
                    );
                  break;
              case /* Script */1 :
              case /* Input */2 :
                  className = mouseHover ? " node-drop drag-target drop-ready" : " node-drop drag-target";
                  break;
              
            }
          } else {
            className = "";
          }
          break;
      case /* StartedSource */0 :
      case /* CompletedPendingVariable */2 :
          exit$3 = 4;
          break;
      case /* Completed */3 :
          exit$1 = 2;
          break;
      case /* CompletedWithTypeMismatch */4 :
          className = "";
          break;
      
    }
  }
  if (exit$3 === 4) {
    if (mouseHover && Caml_obj.caml_notequal(connectionDrag.sourceRequest, request)) {
      className = "node-drop drag-target drop-ready";
    } else {
      exit$2 = 3;
    }
  }
  if (exit$2 === 3) {
    if (Caml_obj.caml_notequal(connectionDrag.sourceRequest, request)) {
      className = "node-drop drag-target";
    } else {
      exit$1 = 2;
    }
  }
  if (exit$1 === 2) {
    var exit$4 = 0;
    if (typeof connectionDrag !== "number") {
      switch (connectionDrag.TAG | 0) {
        case /* CompletedPendingVariable */2 :
            exit = 1;
            break;
        case /* StartedSource */0 :
        case /* Completed */3 :
            exit$4 = 3;
            break;
        
      }
    }
    if (exit$4 === 3) {
      if (Caml_obj.caml_equal(connectionDrag.sourceRequest, request)) {
        className = "node-drop drag-source no-drop";
      } else {
        exit = 1;
      }
    }
    
  }
  if (exit === 1) {
    var exit$5 = 0;
    if (typeof connectionDrag !== "number") {
      switch (connectionDrag.TAG | 0) {
        case /* StartedSource */0 :
        case /* CompletedPendingVariable */2 :
            exit$5 = 2;
            break;
        case /* Completed */3 :
            className = "";
            break;
        
      }
    }
    if (exit$5 === 2) {
      className = Caml_obj.caml_equal(connectionDrag.sourceRequest, request) ? "node-drop drag-source no-drop" : "";
    }
    
  }
  return React.createElement("div", {
              ref: domRef,
              className: "flex align-middle items-center min-w-max flex-row items-stretch " + className,
              onContextMenu: (function ($$event) {
                  
                }),
              onMouseDown: (function ($$event) {
                  if ($$event.altKey) {
                    $$event.preventDefault();
                    $$event.stopPropagation();
                    return Belt_Option.forEach(request, (function (request) {
                                  return Curry._3(onDragStart, $$event, request, domRef.current);
                                }));
                  }
                  
                }),
              onMouseEnter: (function (param) {
                  return Curry._1(setMouseHover, (function (param) {
                                return true;
                              }));
                }),
              onMouseLeave: (function (param) {
                  return Curry._1(setMouseHover, (function (param) {
                                return false;
                              }));
                }),
              onMouseUp: (function ($$event) {
                  return Belt_Option.forEach(request, (function (request) {
                                var clientX = $$event.clientX;
                                var clientY = $$event.clientY;
                                var mouseClientPosition = [
                                  clientX,
                                  clientY
                                ];
                                if (typeof connectionDrag === "number") {
                                  return ;
                                }
                                switch (connectionDrag.TAG | 0) {
                                  case /* StartedSource */0 :
                                      if (Caml_obj.caml_notequal(connectionDrag.sourceRequest, request)) {
                                        return Curry._1(onPotentialVariableSourceConnect, {
                                                    TAG: 2,
                                                    sourceRequest: connectionDrag.sourceRequest,
                                                    sourceDom: connectionDrag.sourceDom,
                                                    targetRequest: request,
                                                    windowPosition: mouseClientPosition,
                                                    [Symbol.for("name")]: "CompletedPendingVariable"
                                                  });
                                      } else {
                                        return ;
                                      }
                                  case /* StartedTarget */1 :
                                      return Curry._1(onPotentialVariableSourceConnect, {
                                                  TAG: 3,
                                                  sourceRequest: request,
                                                  sourceDom: connectionDrag.sourceDom,
                                                  target: connectionDrag.target,
                                                  windowPosition: mouseClientPosition,
                                                  [Symbol.for("name")]: "Completed"
                                                });
                                  default:
                                    return ;
                                }
                              }));
                })
            }, React.createElement("div", {
                  className: indicatorClass + " pl-2",
                  style: {
                    width: "4px"
                  },
                  title: "Data for this block is mocked"
                }), React.createElement("div", {
                  className: "flex flex-row items-center justify-end font-mono"
                }, React.createElement("div", {
                      className: "m-2"
                    }, services), React.createElement("div", {
                      className: "flex-1 inline-block "
                    }, block.title), React.createElement("div", {
                      className: "p-2 hover:shadow-lg rounded-md hover:border-gray-300 cursor-pointer m-0",
                      onClick: (function ($$event) {
                          $$event.preventDefault();
                          return Curry._1(onEditBlock, block);
                        })
                    }, React.createElement(Icons.GraphQL.make, {
                          color: Comps.colors["gray-4"],
                          width: "16px",
                          height: "16px"
                        }))));
}

var NodeLabel = {
  make: ChainEditor$NodeLabel
};

function ChainEditor$OperationNodeComponent(Props) {
  var data = Props.data;
  return React.createElement("div", {
              className: "rounded-sm node-label p-2"
            }, React.createElement("div", undefined, data.label));
}

var OperationNodeComponent = {
  make: ChainEditor$OperationNodeComponent
};

function emptyGraphLevel(level) {
  return {
          nodeCount: 0,
          width: 0,
          nodes: [],
          level: level
        };
}

function diagramFromChain(chain, onEditBlock, onDragStart, schema, onPotentialVariableSourceConnect, param) {
  var nodeStyle = {
    width: "unset"
  };
  var fragmentNodes = Belt_Array.mapWithIndex(Belt_SortArray.stableSortBy(Belt_Array.keep(chain.blocks, (function (block) {
                  var match = block.kind;
                  return match === 3;
                })), (function (a, b) {
              return a.title.localeCompare(b.title) | 0;
            })), (function (idx, block) {
          var nodeTitleWidth = block.title.length * 7.2;
          var x = 160 - nodeTitleWidth - 105;
          return {
                  id: block.id.toString(),
                  type: "fragment",
                  data: {
                    label: React.createElement(ChainEditor$NodeLabel, {
                          request: undefined,
                          block: block,
                          onEditBlock: onEditBlock,
                          onDragStart: onDragStart,
                          schema: schema,
                          onPotentialVariableSourceConnect: onPotentialVariableSourceConnect
                        })
                  },
                  position: {
                    x: x,
                    y: 50 * idx + 10 + 30
                  },
                  draggable: false,
                  connectable: false,
                  className: "node-label",
                  style: nodeStyle
                };
        }));
  var match = fragmentNodes.length;
  var fragmentLabelNode = match !== 0 ? [{
        id: "fragmentColumnLabel",
        type: "fragment",
        data: {
          label: "Reusable Fragments"
        },
        position: {
          x: 5,
          y: 10
        },
        draggable: false,
        connectable: false,
        style: {
          width: "unset"
        }
      }] : [];
  var operationBlocks = Belt_Array.keep(chain.blocks, (function (block) {
          var match = block.kind;
          return match !== 3;
        }));
  var levels = {};
  var graphLevels = {};
  var findReqLevel = function (request) {
    var level = Js_dict.get(levels, request.id);
    if (level !== undefined) {
      return level;
    }
    var highestDependency = Belt_Array.reduce(request.dependencyRequestIds, -2, (function (level, nextId) {
            return Belt_Option.getWithDefault(Belt_Option.flatMap(Belt_Array.getBy(chain.requests, (function (depReq) {
                                  return depReq.id === nextId;
                                })), (function (depReq) {
                              if (depReq.id === request.id) {
                                return ;
                              }
                              var dependencyLevel = findReqLevel(depReq);
                              levels[nextId] = dependencyLevel;
                              return Math.max(level, dependencyLevel);
                            })), level);
          }));
    var requestLevel = highestDependency + 1 | 0;
    var nodeTitleWidth = request.operation.title.length * 7.2;
    var requestWidth = nodeTitleWidth + 105 + 10;
    var graphLevel = Belt_Option.getWithDefault(Js_dict.get(graphLevels, String(requestLevel)), emptyGraphLevel(requestLevel));
    var graphNode_left = graphLevel.width;
    var graphNode = {
      request: request,
      level: requestLevel,
      left: graphNode_left
    };
    var newGraphLevel_nodeCount = graphLevel.nodeCount + 1 | 0;
    var newGraphLevel_width = graphLevel.width + requestWidth;
    var newGraphLevel_nodes = Belt_Array.concat(graphLevel.nodes, [graphNode]);
    var newGraphLevel_level = graphLevel.level;
    var newGraphLevel = {
      nodeCount: newGraphLevel_nodeCount,
      width: newGraphLevel_width,
      nodes: newGraphLevel_nodes,
      level: newGraphLevel_level
    };
    graphLevels[String(requestLevel)] = newGraphLevel;
    return requestLevel;
  };
  Belt_Array.forEach(operationBlocks, (function (block) {
          var req = Belt_Array.getBy(chain.requests, (function (req) {
                  return req.id === block.title;
                }));
          return Belt_Option.forEach(req, (function (req) {
                        var level = findReqLevel(req);
                        levels[req.id] = level;
                        
                      }));
        }));
  var totalWidth = Belt_Array.reduce(Js_dict.values(graphLevels), 0, (function (highest, next) {
          if (next.width > highest) {
            return next.width;
          } else {
            return highest;
          }
        }));
  var operationNodes = Belt_Array.concatMany(Belt_Array.map(Belt_SortArray.stableSortBy(Js_dict.values(graphLevels), (function (a, b) {
                  return a.level - b.level | 0;
                })), (function (graphLevel) {
              return Belt_Array.map(graphLevel.nodes, (function (node) {
                            var req = node.request;
                            var block = req.operation;
                            var variables = Card.getFirstVariables(block);
                            var hasVariables = variables.length !== 0;
                            var typ = hasVariables ? "default" : "input";
                            var level = node.level;
                            var halfWidth = totalWidth / 2;
                            var furthestLeft = halfWidth - graphLevel.width / 2;
                            var x = 250 + furthestLeft + node.left;
                            return {
                                    id: block.id.toString(),
                                    type: typ,
                                    data: {
                                      label: React.createElement(ChainEditor$NodeLabel, {
                                            request: node.request,
                                            block: block,
                                            onEditBlock: onEditBlock,
                                            onDragStart: onDragStart,
                                            schema: schema,
                                            onPotentialVariableSourceConnect: onPotentialVariableSourceConnect
                                          })
                                    },
                                    position: {
                                      x: x,
                                      y: 100 + (50 + 10.0) * level
                                    },
                                    draggable: true,
                                    connectable: true,
                                    className: "node-label",
                                    style: nodeStyle
                                  };
                          }));
            })));
  var argDepEdges = Belt_Array.concatMany(Belt_Array.map(chain.blocks, (function (block) {
              var req = Belt_Array.getBy(chain.requests, (function (req) {
                      return req.id === block.title;
                    }));
              var target = block.id.toString();
              return Belt_Array.concatMany(Belt_Option.getWithDefault(Belt_Option.map(req, (function (req) {
                                    var ast = Graphql.parse(req.operation.body);
                                    var variables = Belt_Option.getWithDefault(Belt_Option.getExn(Belt_Array.get(ast.definitions, 0)).variableDefinitions, []);
                                    return Belt_Array.map(variables, (function (varDef) {
                                                  var varName = varDef.variable.name.value;
                                                  var argDep = Belt_Option.flatMap(Belt_Array.getBy(req.variableDependencies, (function (argDep) {
                                                              var match = argDep.name === varName;
                                                              var match$1 = argDep.dependency;
                                                              if (!match) {
                                                                return false;
                                                              }
                                                              switch (match$1.TAG | 0) {
                                                                case /* ArgumentDependency */0 :
                                                                    return true;
                                                                case /* Direct */1 :
                                                                case /* GraphQLProbe */2 :
                                                                    return false;
                                                                
                                                              }
                                                            })), (function (argDep) {
                                                          var dep = argDep.dependency;
                                                          switch (dep.TAG | 0) {
                                                            case /* ArgumentDependency */0 :
                                                                return dep._0;
                                                            case /* Direct */1 :
                                                            case /* GraphQLProbe */2 :
                                                                return ;
                                                            
                                                          }
                                                        }));
                                                  if (argDep === undefined) {
                                                    return [];
                                                  }
                                                  var edges = Belt_Array.keepMap(argDep.fromRequestIds, (function (requestId) {
                                                          var requestDependency = Belt_Array.getBy(chain.requests, (function (existingRequest) {
                                                                  return existingRequest.id === requestId;
                                                                }));
                                                          return Belt_Option.map(requestDependency, (function (requestDependency) {
                                                                        var source = requestDependency.operation.id.toString();
                                                                        var id = source + "-" + target;
                                                                        var edge = {
                                                                          id: id,
                                                                          source: source,
                                                                          target: target
                                                                        };
                                                                        return [
                                                                                id,
                                                                                edge
                                                                              ];
                                                                      }));
                                                        }));
                                                  return Belt_Array.reduce(edges, [
                                                                undefined,
                                                                []
                                                              ], (function (param, param$1) {
                                                                  var id = param$1[0];
                                                                  var edges = param[1];
                                                                  var distinct = param[0];
                                                                  if (Belt_SetString.has(distinct, id)) {
                                                                    return [
                                                                            distinct,
                                                                            edges
                                                                          ];
                                                                  } else {
                                                                    return [
                                                                            Belt_SetString.add(distinct, id),
                                                                            Belt_Array.concat(edges, [param$1[1]])
                                                                          ];
                                                                  }
                                                                }))[1];
                                                }));
                                  })), []));
            })));
  var reqEdge = Belt_Array.concatMany(Belt_Array.map(chain.requests, (function (request) {
              var target = request.operation.id.toString();
              return Belt_Array.keepMap(request.dependencyRequestIds, (function (requestId) {
                            var reifiedRequest = Belt_Array.getBy(chain.requests, (function (req) {
                                    return req.id === requestId;
                                  }));
                            return Belt_Option.map(reifiedRequest, (function (requestDependency) {
                                          var source = requestDependency.operation.id.toString();
                                          var id = source + "-" + target;
                                          return {
                                                  id: id,
                                                  source: source,
                                                  target: target
                                                };
                                        }));
                          }));
            })));
  var match$1 = Belt_Array.reduce(Belt_Array.concat(argDepEdges, reqEdge), [
        undefined,
        []
      ], (function (param, edge) {
          var edges = param[1];
          var distinct = param[0];
          if (Belt_SetString.has(distinct, edge.id)) {
            return [
                    distinct,
                    edges
                  ];
          } else {
            return [
                    Belt_SetString.add(distinct, edge.id),
                    Belt_Array.concat(edges, [edge])
                  ];
          }
        }));
  var edges = Belt_Array.map(match$1[1], (function (param) {
          return {
                  id: param.id,
                  source: param.source,
                  target: param.target,
                  style: {
                    stroke: "rgb(78,160,23)",
                    strokeWidth: "2px"
                  },
                  animated: true,
                  type: "step"
                };
        }));
  var nodes = Belt_Array.concat(fragmentNodes, operationNodes);
  var elements = Belt_Array.concatMany([
        nodes,
        edges,
        fragmentLabelNode
      ]);
  return {
          nodes: nodes,
          edges: edges,
          elements: elements
        };
}

var backgroundStyle = {
  backgroundColor: "rgb(60, 60, 60)",
  backgroundImage: "linear-gradient(0deg, transparent 24%, rgba(255, 255, 255, 0.05) 25%, rgba(255, 255, 255, 0.05) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, 0.05) 75%, rgba(255, 255, 255, 0.05) 76%, transparent 77%, transparent), linear-gradient(90deg, transparent 24%, rgba(255, 255, 255, 0.05) 25%, rgba(255, 255, 255, 0.05) 26%, transparent 27%, transparent 74%, rgba(255, 255, 255, 0.05) 75%, rgba(255, 255, 255, 0.05) 76%, transparent 77%, transparent)",
  display: "flex",
  height: "100%",
  backgroundSize: "50px 50px",
  borderRadius: "0px"
};

function ChainEditor$ConnectorLine(Props) {
  var source = Props.source;
  var onDragEnd = Props.onDragEnd;
  var invert = Props.invert;
  var match = React.useState(function () {
        var rect = source.getBoundingClientRect();
        return {
                mousePosition: [
                  rect.x + (rect.width / 2 | 0) | 0,
                  rect.y + (rect.height / 2 | 0) | 0
                ]
              };
      });
  var setState = match[1];
  var onMouseMove = function ($$event) {
    var x = $$event.pageX;
    var y = $$event.pageY;
    return Curry._1(setState, (function (_oldState) {
                  return {
                          mousePosition: [
                            x,
                            y
                          ]
                        };
                }));
  };
  var onMouseUp = function ($$event) {
    Debug.assignToWindowForDeveloperDebug("mouseupevent", $$event);
    return Curry._1(onDragEnd, undefined);
  };
  React.useEffect((function () {
          Belt_Option.forEach(Caml_option.undefined_to_opt(typeof window === "undefined" ? undefined : window), (function ($$window) {
                  $$window.document.addEventListener("mousemove", onMouseMove);
                  return $$window.document.addEventListener("mouseup", onMouseUp);
                }));
          return Belt_Option.map(Caml_option.undefined_to_opt(typeof window === "undefined" ? undefined : window), (function ($$window, param) {
                        $$window.document.removeEventListener("mousemove", onMouseMove);
                        return $$window.document.removeEventListener("mouseup", onMouseUp);
                      }));
        }), []);
  var match$1 = match[0].mousePosition;
  var mouseY = match$1[1];
  var mouseX = match$1[0];
  var rect = source.getBoundingClientRect();
  var scrollY = Belt_Option.getWithDefault(Utils.$$Window.scrollY(undefined), 0);
  var anchorX = rect.x + (rect.width / 2 | 0) | 0;
  var anchorY = (rect.y + (rect.height / 2 | 0) | 0) + scrollY | 0;
  var match$2 = invert ? [
      mouseX - 2 | 0,
      mouseY - 2 | 0,
      anchorX,
      anchorY
    ] : [
      anchorX,
      anchorY,
      mouseX - 2 | 0,
      mouseY - 2 | 0
    ];
  var endY = match$2[3];
  var endX = match$2[2];
  var startY = match$2[1];
  var startX = match$2[0];
  return React.createElement("div", {
              className: "absolute w-full h-full pointer-events-none",
              style: {
                cursor: "none",
                left: "0px",
                top: "0px",
                zIndex: "9999"
              },
              onMouseMove: (function ($$event) {
                  var x = $$event.clientX;
                  var y = $$event.clientY;
                  return Curry._1(setState, (function (_oldState) {
                                return {
                                        mousePosition: [
                                          x,
                                          y
                                        ]
                                      };
                              }));
                })
            }, React.createElement("svg", {
                  className: "relative w-full h-full pointer-events-none",
                  style: {
                    cursor: "none",
                    left: "0px",
                    top: "0px",
                    zIndex: "9999"
                  },
                  xmlns: "http://www.w3.org/2000/svg"
                }, React.createElement("filter", {
                      id: "blurMe"
                    }, React.createElement("feGaussianBlur", {
                          in: "SourceGraphic",
                          stdDeviation: "5"
                        })), React.createElement("marker", {
                      id: "connectMarker",
                      markerHeight: "4",
                      markerWidth: "2",
                      orient: "auto",
                      refX: "0.1",
                      refY: "2"
                    }, React.createElement("path", {
                          d: "M0 0v4l2-2z",
                          fill: "green"
                        })), React.createElement("line", {
                      className: "pointer-events-none",
                      style: {
                        cursor: "none"
                      },
                      markerEnd: "url(#connectMarker)",
                      stroke: Comps.colors["green-6"],
                      strokeWidth: "3",
                      x1: String(startX),
                      x2: String(endX),
                      y1: String(startY),
                      y2: String(endY)
                    }), React.createElement("line", {
                      className: "moving-path pointer-events-none",
                      style: {
                        cursor: "none"
                      },
                      markerEnd: "url(#connectMarker)",
                      stroke: Comps.colors["green-3"],
                      strokeDasharray: "50",
                      strokeWidth: "3",
                      x1: String(startX),
                      x2: String(endX),
                      y1: String(startY),
                      y2: String(endY)
                    })));
}

var ConnectorLine = {
  make: ChainEditor$ConnectorLine
};

function ChainEditor$Diagram(Props) {
  var setState = Props.setState;
  var diagram = Props.diagram;
  var chain = Props.chain;
  var removeEdge = Props.removeEdge;
  var removeRequest = Props.removeRequest;
  var diagramFromChain = Props.diagramFromChain;
  var trace = Props.trace;
  return React.createElement(ReactFlowRenderer$1, {
              elements: diagram.elements,
              style: {
                borderColor: Comps.colors["gray-10"],
                borderStyle: "solid",
                borderWidth: "1px"
              },
              onElementClick: (function (param, node) {
                  var id = node.id;
                  var request = Belt_Option.map(Belt_Array.getBy(chain.requests, (function (req) {
                              return req.operation.id.toString() === id;
                            })), (function (req) {
                          return {
                                  TAG: 2,
                                  chain: chain,
                                  request: req,
                                  [Symbol.for("name")]: "Request"
                                };
                        }));
                  var inspected;
                  if (request !== undefined) {
                    inspected = request;
                  } else {
                    var block = Belt_Array.getBy(chain.blocks, (function (block) {
                            return block.id.toString() === id;
                          }));
                    inspected = Belt_Option.map(block, (function (block) {
                            return {
                                    TAG: 1,
                                    _0: block,
                                    [Symbol.for("name")]: "Block"
                                  };
                          }));
                  }
                  return Belt_Option.forEach(inspected, (function (inspected) {
                                return Curry._1(setState, (function (oldState) {
                                              var newrecord = Caml_obj.caml_obj_dup(oldState);
                                              newrecord.inspected = inspected;
                                              return newrecord;
                                            }));
                              }));
                }),
              onElementsRemove: (function (elements) {
                  return Curry._1(setState, (function (oldState) {
                                var newChain = Belt_Array.reduce(elements, oldState.chain, (function (accChain, element) {
                                        var match = element.source;
                                        var match$1 = element.target;
                                        var typ = match !== undefined && match$1 !== undefined ? ({
                                              NAME: "edge",
                                              VAL: [
                                                match,
                                                match$1
                                              ]
                                            }) : ({
                                              NAME: "node",
                                              VAL: element.id
                                            });
                                        if (typ.NAME === "node") {
                                          var source = typ.VAL;
                                          var targetRequest = Belt_Array.getBy(accChain.requests, (function (request) {
                                                  return Caml_obj.caml_equal(request.operation.id, source);
                                                }));
                                          return Belt_Option.getWithDefault(Belt_Option.map(targetRequest, (function (targetRequest) {
                                                            return Curry._2(removeRequest, accChain, targetRequest);
                                                          })), accChain);
                                        }
                                        var match$2 = typ.VAL;
                                        return Curry._3(removeEdge, accChain, match$2[0], match$2[1]);
                                      }));
                                var diagram = Curry._1(diagramFromChain, newChain);
                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                newrecord.inspected = {
                                  TAG: 0,
                                  chain: newChain,
                                  trace: undefined,
                                  [Symbol.for("name")]: "Nothing"
                                };
                                newrecord.chain = newChain;
                                newrecord.diagram = diagram;
                                return newrecord;
                              }));
                }),
              connectionLineType: "smoothstep",
              onPaneClick: (function (param) {
                  return Curry._1(setState, (function (oldState) {
                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                newrecord.inspected = {
                                  TAG: 0,
                                  chain: oldState.chain,
                                  trace: trace,
                                  [Symbol.for("name")]: "Nothing"
                                };
                                return newrecord;
                              }));
                }),
              onConnect: (function (info) {
                  var source = info.source;
                  var target = info.target;
                  var sourceRequest = Belt_Array.getBy(chain.requests, (function (request) {
                          return request.operation.id.toString() === source;
                        }));
                  var targetRequest = Belt_Array.getBy(chain.requests, (function (request) {
                          return request.operation.id.toString() === target;
                        }));
                  if (sourceRequest !== undefined && targetRequest !== undefined) {
                    return Curry._1(setState, (function (oldState) {
                                  var newRequests = Belt_Array.map(oldState.chain.requests, (function (request) {
                                          if (targetRequest.id !== request.id) {
                                            return request;
                                          }
                                          var varDeps = Belt_Array.map(request.variableDependencies, (function (varDep) {
                                                  var argDep = varDep.dependency;
                                                  var dependency;
                                                  switch (argDep.TAG | 0) {
                                                    case /* ArgumentDependency */0 :
                                                        var argDep$1 = argDep._0;
                                                        var newArgDep_functionFromScript = argDep$1.functionFromScript;
                                                        var newArgDep_maxRecur = argDep$1.maxRecur;
                                                        var newArgDep_ifMissing = argDep$1.ifMissing;
                                                        var newArgDep_ifList = argDep$1.ifList;
                                                        var newArgDep_fromRequestIds = Utils.$$String.distinctStrings(Belt_Array.concat(argDep$1.fromRequestIds, [sourceRequest.id]));
                                                        var newArgDep_name = argDep$1.name;
                                                        var newArgDep = {
                                                          functionFromScript: newArgDep_functionFromScript,
                                                          maxRecur: newArgDep_maxRecur,
                                                          ifMissing: newArgDep_ifMissing,
                                                          ifList: newArgDep_ifList,
                                                          fromRequestIds: newArgDep_fromRequestIds,
                                                          name: newArgDep_name
                                                        };
                                                        dependency = {
                                                          TAG: 0,
                                                          _0: newArgDep,
                                                          [Symbol.for("name")]: "ArgumentDependency"
                                                        };
                                                        break;
                                                    case /* Direct */1 :
                                                    case /* GraphQLProbe */2 :
                                                        dependency = argDep;
                                                        break;
                                                    
                                                  }
                                                  return {
                                                          name: varDep.name,
                                                          dependency: dependency
                                                        };
                                                }));
                                          return {
                                                  id: request.id,
                                                  variableDependencies: varDeps,
                                                  operation: request.operation,
                                                  dependencyRequestIds: Utils.$$String.distinctStrings(Belt_Array.concat(request.dependencyRequestIds, [sourceRequest.id]))
                                                };
                                        }));
                                  var sortedRequests = Chain.toposortRequests(newRequests);
                                  if (sortedRequests.TAG !== /* Ok */0) {
                                    return oldState;
                                  }
                                  var init = oldState.chain;
                                  var newChain_name = init.name;
                                  var newChain_description = init.description;
                                  var newChain_id = init.id;
                                  var newChain_script = init.script;
                                  var newChain_scriptDependencies = init.scriptDependencies;
                                  var newChain_requests = sortedRequests._0;
                                  var newChain_blocks = init.blocks;
                                  var newChain_accessToken = init.accessToken;
                                  var newChain_traceRetentionPolicy = init.traceRetentionPolicy;
                                  var newChain_yjsScript = init.yjsScript;
                                  var newChain = {
                                    name: newChain_name,
                                    description: newChain_description,
                                    id: newChain_id,
                                    script: newChain_script,
                                    scriptDependencies: newChain_scriptDependencies,
                                    requests: newChain_requests,
                                    blocks: newChain_blocks,
                                    accessToken: newChain_accessToken,
                                    traceRetentionPolicy: newChain_traceRetentionPolicy,
                                    yjsScript: newChain_yjsScript
                                  };
                                  var diagram = Curry._1(diagramFromChain, newChain);
                                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                                  newrecord.chain = newChain;
                                  newrecord.diagram = diagram;
                                  return newrecord;
                                }));
                  } else {
                    console.warn("Couldn't find source or target request to connect");
                    return ;
                  }
                }),
              zoomOnScroll: false,
              panOnScroll: true,
              onNodeContextMenu: (function (_event, _node) {
                  
                }),
              onPaneContextMenu: (function ($$event) {
                  
                }),
              children: null,
              nodeTypes: {
                fragment: make
              }
            }, React.createElement(ReactFlowRenderer.Controls, {
                  showZoom: false,
                  showFitView: true,
                  showInteractive: false
                }), React.createElement(ReactFlowRenderer.Background, {
                  variant: "lines",
                  gap: 20,
                  size: 1,
                  color: Comps.colors["gray-1"],
                  style: {
                    backgroundColor: "rgb(31, 33, 37)"
                  }
                }));
}

var Diagram = {
  make: ChainEditor$Diagram
};

var draggablePattern = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAABaADAAQAAAABAAAABQAAAAB/qhzxAAAAGElEQVQIHWNgwAWmTJnyH4Rh8kwwBnk0AJwCBXmDfKBPAAAAAElFTkSuQmCC) repeat";

function ChainEditor$PopupPicker(Props) {
  var top = Props.top;
  var left = Props.left;
  var widthOpt = Props.width;
  var titleOpt = Props.title;
  var children = Props.children;
  var onClose = Props.onClose;
  var width = widthOpt !== undefined ? widthOpt : "500px";
  var title = titleOpt !== undefined ? titleOpt : "";
  ReactHotkeysHook.useHotkeys("esc", (function (_event, _handler) {
          return Curry._1(onClose, undefined);
        }), {}, undefined);
  return React.createElement(ReactDraggable, {
              children: React.createElement("div", {
                    className: "absolute graphql-structure-container rounded-sm text-gray-200",
                    style: {
                      color: Comps.colors["gray-6"],
                      left: String(left) + "px",
                      maxHeight: "200px",
                      overflowY: "scroll",
                      top: String(top) + "px",
                      width: width,
                      zIndex: "999"
                    }
                  }, React.createElement("div", {
                        style: {
                          color: Comps.colors["gray-6"],
                          cursor: "move",
                          display: "flex",
                          height: "15px",
                          width: "100%",
                          justifyContent: "space-between"
                        }
                      }, React.createElement("span", {
                            className: "text-white cursor-move flex-grow flex-1 mr-4 mt mb",
                            style: {
                              background: draggablePattern
                            }
                          }, title), React.createElement("span", {
                            className: "text-white cursor-pointer",
                            onClick: (function (param) {
                                return Curry._1(onClose, undefined);
                              })
                          }, "⨂")), children)
            });
}

var PopupPicker = {
  draggablePattern: draggablePattern,
  make: ChainEditor$PopupPicker
};

function chainResultToRequestValueCache(chainExecutionResults) {
  return Belt_Array.reduce(chainExecutionResults.data.oneGraph.executeChain.results, {}, (function (acc, next) {
                var reqId = next.request.id;
                var result = Belt_Option.flatMap(Belt_Array.get(next.result, 0), (function (prim) {
                        if (prim == null) {
                          return ;
                        } else {
                          return Caml_option.some(prim);
                        }
                      }));
                if (result !== undefined) {
                  acc[reqId] = result;
                }
                return acc;
              }));
}

function persistChain(config, schema, authToken, chain, onComplete) {
  var appId = config.oneGraphAppId;
  var webhookUrl = Inspector.webhookUrlForAppId(config.oneGraphAppId);
  var compiled = Curry._1(Inspector.transformChain(chain)(schema), webhookUrl);
  var targetChain = compiled.chains[0];
  var freeVariables = Belt_Array.map(targetChain.exposedVariables, (function (exposed) {
          return exposed.exposedName;
        }));
  return OneGraphRe.persistQuery(appId, config.persistQueryToken, compiled.operationDoc, freeVariables, config.chainAccessToken, undefined, (function (results) {
                try {
                  var docId = results.data.oneGraph.createPersistedQuery.persistedQuery.id;
                  Chain.saveToLocalStorage(chain);
                  return Curry._1(onComplete, docId);
                }
                catch (raw_ex){
                  var ex = Caml_js_exceptions.internalToOCamlException(raw_ex);
                  console.error("Error saving chain locally", ex);
                  return ;
                }
              }));
}

function ChainEditor$Main(Props) {
  var schema = Props.schema;
  var initialChain = Props.initialChain;
  var config = Props.config;
  var oneGraphAuth = Props.oneGraphAuth;
  var onSaveChain = Props.onSaveChain;
  var onClose = Props.onClose;
  var initialTrace = Props.trace;
  var helpOpen = Props.helpOpen;
  var match = React.useState(function () {
        return [];
      });
  var setMissingAuthServices = match[1];
  var match$1 = React.useState(function () {
        var scriptFunctions;
        try {
          scriptFunctions = Acorn.collectExportedFunctionNames(Acorn$1.parse(initialChain.script, {
                    ecmaVersion: 2020,
                    sourceType: "module"
                  }));
        }
        catch (exn){
          scriptFunctions = [];
        }
        var inspected = {
          TAG: 0,
          chain: initialChain,
          trace: initialTrace,
          [Symbol.for("name")]: "Nothing"
        };
        return {
                audioLevel: 0,
                audioStream: /* Empty */0,
                diagram: undefined,
                card: Card.watchTwitterFollower,
                schema: schema,
                chain: initialChain,
                compiledChain: compileChain(schema, initialChain),
                chainResult: undefined,
                scriptFunctions: scriptFunctions,
                chainExecutionResults: undefined,
                blocks: Card.blocks,
                inspected: inspected,
                blockEdit: /* Nothing */0,
                blockSearchOpen: true,
                scriptEditor: {
                  isOpen: true,
                  editor: undefined,
                  monaco: undefined
                },
                savedChainId: undefined,
                requestValueCache: RequestValueCache.make(undefined),
                debugUIItems: [],
                connectionDrag: /* Empty */0,
                subscriptionClient: undefined,
                trace: initialTrace,
                insight: {
                  store: new RecordStore.RecordStore(),
                  latestRunId: 0,
                  previousRunId: -1
                }
              };
      });
  var setState = match$1[1];
  var state = match$1[0];
  React.useEffect((function () {
          return (function (param) {
                    
                  });
        }), []);
  React.useEffect((function () {
          var diagramFromChain$1 = function (chain) {
            return diagramFromChain(chain, (function (block) {
                          return Curry._1(setState, (function (oldState) {
                                        var newrecord = Caml_obj.caml_obj_dup(oldState);
                                        newrecord.blockEdit = {
                                          TAG: 1,
                                          _0: block,
                                          [Symbol.for("name")]: "Edit"
                                        };
                                        return newrecord;
                                      }));
                        }), (function (param, request, domRef) {
                          var connectionDrag = Belt_Option.mapWithDefault((domRef == null) ? undefined : Caml_option.some(domRef), /* Empty */0, (function (domRef) {
                                  return {
                                          TAG: 0,
                                          sourceRequest: request,
                                          sourceDom: domRef,
                                          [Symbol.for("name")]: "StartedSource"
                                        };
                                }));
                          return Curry._1(setState, (function (oldState) {
                                        var newrecord = Caml_obj.caml_obj_dup(oldState);
                                        newrecord.connectionDrag = connectionDrag;
                                        return newrecord;
                                      }));
                        }), schema, (function (param) {
                          
                        }), undefined);
          };
          var diagram = diagramFromChain$1(state.chain);
          Curry._1(setState, (function (oldState) {
                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                  newrecord.diagram = diagram;
                  return newrecord;
                }));
          
        }), []);
  var debouncedScript = Hooks.useLeadingDebounce(state.chain.script, 100);
  React.useEffect((function () {
          var runId = state.insight.latestRunId + 1 | 0;
          var transformed = Inspector.babelTranspile(debouncedScript, "/index.js", runId);
          if (transformed.TAG === /* Ok */0) {
            var transformed$1 = transformed._0;
            var invocations = Inspector.babelInvocations(schema, state.trace, state.chain, state.requestValueCache).join("\n\n");
            var fullTransformed_code = transformed$1.code + "\n\n" + invocations;
            var fullTransformed_map = transformed$1.map;
            var fullTransformed_ast = transformed$1.ast;
            var fullTransformed = {
              code: fullTransformed_code,
              map: fullTransformed_map,
              ast: fullTransformed_ast
            };
            var __x = QuickjsEmscripten.getQuickJS();
            __x.then(function (quickjs) {
                  return Promise.resolve(Debug.assignToWindowForDeveloperDebug("quickjs", quickjs));
                });
            Debug.assignToWindowForDeveloperDebug("fullTransformedCode", fullTransformed_code);
            Inspector.evalBabelInQuick(fullTransformed, state.insight, (function (param, store) {
                    return Curry._1(setState, (function (oldState) {
                                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                                  newrecord.insight = {
                                    store: store,
                                    latestRunId: runId,
                                    previousRunId: oldState.insight.latestRunId
                                  };
                                  return newrecord;
                                }));
                  }), (function (err) {
                    console.warn("Error hyperevaling: ", err);
                    
                  }));
          }
          
        }), [
        state.requestValueCache,
        debouncedScript,
        state.trace
      ]);
  var onPotentialVariableSourceConnect = function (connectionDrag) {
    return Curry._1(setState, (function (oldState) {
                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                  newrecord.connectionDrag = connectionDrag;
                  return newrecord;
                }));
  };
  var diagramFromChain$1 = function (chain) {
    return diagramFromChain(chain, (function (block) {
                  return Curry._1(setState, (function (oldState) {
                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                newrecord.blockEdit = {
                                  TAG: 1,
                                  _0: block,
                                  [Symbol.for("name")]: "Edit"
                                };
                                return newrecord;
                              }));
                }), (function (param, request, domRef) {
                  var connectionDrag = Belt_Option.mapWithDefault((domRef == null) ? undefined : Caml_option.some(domRef), /* Empty */0, (function (domRef) {
                          return {
                                  TAG: 0,
                                  sourceRequest: request,
                                  sourceDom: domRef,
                                  [Symbol.for("name")]: "StartedSource"
                                };
                        }));
                  return Curry._1(setState, (function (oldState) {
                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                newrecord.connectionDrag = connectionDrag;
                                return newrecord;
                              }));
                }), schema, onPotentialVariableSourceConnect, undefined);
  };
  var match$2 = ReactFlowRenderer.useZoomPanHelper();
  var fitView = match$2.fitView;
  var availableFragments = Belt_Array.keepMap(state.chain.blocks, (function (block) {
          var match = block.kind;
          if (match !== 3) {
            return ;
          } else {
            return Caml_array.get(Graphql.parse(block.body).definitions, 0);
          }
        }));
  var onRequestInspected = function (request) {
    var inspected_0 = state.chain;
    var inspected = {
      TAG: 2,
      chain: inspected_0,
      request: request,
      [Symbol.for("name")]: "Request"
    };
    return Curry._1(setState, (function (oldState) {
                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                  newrecord.inspected = inspected;
                  return newrecord;
                }));
  };
  React.useEffect((function () {
          var handler = function ($$event) {
            console.log("onCopy: ", $$event);
            
          };
          Utils.$$Window.addEventListener("copy", handler);
          return (function (param) {
                    return Utils.$$Window.removeEventListener("copy", handler);
                  });
        }), [state.chain.blocks]);
  React.useEffect((function () {
          var handler = function ($$event) {
            console.log("onPaste: ", $$event);
            
          };
          Utils.$$Window.addEventListener("paste", handler);
          return (function (param) {
                    return Utils.$$Window.removeEventListener("paste", handler);
                  });
        }), [state.chain.blocks]);
  React.useEffect((function () {
          Curry._1(setState, (function (oldState) {
                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                  var init = oldState.chain;
                  newrecord.chain = {
                    name: initialChain.name,
                    description: init.description,
                    id: init.id,
                    script: init.script,
                    scriptDependencies: init.scriptDependencies,
                    requests: init.requests,
                    blocks: init.blocks,
                    accessToken: init.accessToken,
                    traceRetentionPolicy: init.traceRetentionPolicy,
                    yjsScript: init.yjsScript
                  };
                  return newrecord;
                }));
          
        }), [initialChain.name]);
  React.useEffect((function () {
          if (state.chain.requests.length > 3) {
            Curry._1(fitView, {
                  padding: 0.2,
                  includeHiddenNodes: false
                });
          }
          
        }), [state.chain.requests.length]);
  var trace = state.trace;
  var definitionResultData = trace !== undefined ? chainResultToRequestValueCache(trace.trace) : state.requestValueCache;
  var onExecuteRequest = function (request, variables, authToken) {
    var ast = Graphql.parse(request.operation.body);
    var operationName = Caml_array.get(ast.definitions, 0).name.value;
    var chainFragments = Belt_Array.keepMap(state.chain.blocks, (function (block) {
              var match = block.kind;
              if (match !== 3) {
                return ;
              } else {
                return block.body;
              }
            })).join("\n\n");
    var fullDoc = (request.operation.body + "\n\n" + chainFragments).trim();
    var oneGraphAuth$1 = Belt_Option.getWithDefault(Belt_Option.flatMap(authToken, (function (authToken) {
                var tempAuth = OneGraphAuth.create({
                      appId: config.oneGraphAppId,
                      saveAuthToStorage: false
                    });
                Belt_Option.forEach(tempAuth, (function (tempAuth) {
                        var accessToken = {
                          accessToken: authToken
                        };
                        tempAuth.setToken(accessToken);
                        
                      }));
                return tempAuth;
              })), oneGraphAuth);
    var promise = OneGraphRe.fetchOneGraph(oneGraphAuth$1, fullDoc, operationName, Caml_option.some(variables));
    promise.then(function (result) {
          return Promise.resolve(Curry._1(setState, (function (oldState) {
                            RequestValueCache.set(oldState.requestValueCache, request.id, result);
                            var newOne = RequestValueCache.copy(oldState.requestValueCache);
                            var newrecord = Caml_obj.caml_obj_dup(oldState);
                            newrecord.requestValueCache = newOne;
                            return newrecord;
                          })));
        });
    
  };
  var addBlock = function (superBlock) {
    var ast = Graphql.parse(superBlock.body);
    var blocks = Belt_Array.map(ast.definitions, (function (definition) {
            var services = Belt_Array.map(GraphQLUtils.gatherAllReferencedServices(schema, definition), (function (service) {
                    return service.slug;
                  }));
            var blank = makeBlankBlock("query");
            var match = definition.operation;
            return {
                    id: Uuid.v4(),
                    title: definition.name.value,
                    description: blank.description,
                    body: Graphql.print(definition),
                    kind: match !== undefined ? (
                        match === "mutation" ? /* Mutation */1 : (
                            match === "subscription" ? /* Subscription */2 : /* Query */0
                          )
                      ) : /* Fragment */3,
                    contributedBy: blank.contributedBy,
                    services: services
                  };
          }));
    var inspectedReq = {
      contents: undefined
    };
    var newChain = Belt_Array.reduce(blocks, state.chain, (function (newChain, block) {
            var match = block.kind;
            if (match === 3) {
              return {
                      name: newChain.name,
                      description: newChain.description,
                      id: newChain.id,
                      script: newChain.script,
                      scriptDependencies: newChain.scriptDependencies,
                      requests: newChain.requests,
                      blocks: Belt_Array.concat(newChain.blocks, [block]),
                      accessToken: newChain.accessToken,
                      traceRetentionPolicy: newChain.traceRetentionPolicy,
                      yjsScript: newChain.yjsScript
                    };
            }
            var operationDoc = Graphql.parse(block.body);
            var definition = Caml_array.get(operationDoc.definitions, 0);
            var variableNames = GraphQLUtils.getOperationVariables(definition);
            var variableDependencies = Belt_Array.map(variableNames, (function (param) {
                    var variableName = param[0];
                    return {
                            name: variableName,
                            dependency: {
                              TAG: 1,
                              _0: {
                                name: variableName,
                                value: {
                                  TAG: 1,
                                  _0: variableName,
                                  [Symbol.for("name")]: "Variable"
                                }
                              },
                              [Symbol.for("name")]: "Direct"
                            }
                          };
                  }));
            var newReq_id = block.title;
            var newReq_dependencyRequestIds = [];
            var newReq = {
              id: newReq_id,
              variableDependencies: variableDependencies,
              operation: block,
              dependencyRequestIds: newReq_dependencyRequestIds
            };
            inspectedReq.contents = newReq;
            var names = Chain.requestScriptNames(newReq);
            var nameExistsInScript = Belt_Option.isSome(Caml_option.null_to_opt(newChain.script.match(new RegExp("export function " + names.functionName))));
            var match$1 = Chain.requestHasComputedVariables(newReq);
            var newScript = match$1 && !nameExistsInScript ? newChain.script + ("\n\nexport function " + names.functionName + " (payload : " + names.inputTypeName + ") : " + names.returnTypeName + " {\n  return {}\n}") : newChain.script;
            var newChain_name = newChain.name;
            var newChain_description = newChain.description;
            var newChain_id = newChain.id;
            var newChain_scriptDependencies = newChain.scriptDependencies;
            var newChain_requests = Belt_Array.concat(newChain.requests, [newReq]);
            var newChain_blocks = Belt_Array.concat(newChain.blocks, [block]);
            var newChain_accessToken = newChain.accessToken;
            var newChain_traceRetentionPolicy = newChain.traceRetentionPolicy;
            var newChain_yjsScript = newChain.yjsScript;
            var newChain$1 = {
              name: newChain_name,
              description: newChain_description,
              id: newChain_id,
              script: newScript,
              scriptDependencies: newChain_scriptDependencies,
              requests: newChain_requests,
              blocks: newChain_blocks,
              accessToken: newChain_accessToken,
              traceRetentionPolicy: newChain_traceRetentionPolicy,
              yjsScript: newChain_yjsScript
            };
            var match$2 = Chain.monacoTypelibForChain(schema, newChain$1);
            var importLine = match$2.importLine;
            var hasImport = Belt_Option.isSome(Caml_option.null_to_opt(newScript.match(new RegExp("import[\\s\\S.]+from[\\s\\S]+'oneGraphStudio';"))));
            var newScript$1 = hasImport ? newScript.replace(new RegExp("import[\\s\\S.]+from[\\s\\S]+'oneGraphStudio';"), importLine) : importLine + "\n\n" + newScript;
            return {
                    name: newChain_name,
                    description: newChain_description,
                    id: newChain_id,
                    script: newScript$1,
                    scriptDependencies: newChain_scriptDependencies,
                    requests: newChain_requests,
                    blocks: newChain_blocks,
                    accessToken: newChain_accessToken,
                    traceRetentionPolicy: newChain_traceRetentionPolicy,
                    yjsScript: newChain_yjsScript
                  };
          }));
    var diagram = diagramFromChain$1(newChain);
    var inspected = Belt_Option.getWithDefault(Belt_Option.map(inspectedReq.contents, (function (request) {
                return {
                        TAG: 2,
                        chain: newChain,
                        request: request,
                        [Symbol.for("name")]: "Request"
                      };
              })), state.inspected);
    return Curry._1(setState, (function (oldState) {
                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                  newrecord.inspected = inspected;
                  newrecord.chain = newChain;
                  newrecord.diagram = diagram;
                  return newrecord;
                }));
  };
  var removeRequest = function (oldChain, targetRequest) {
    var newRequests = Belt_Array.keepMap(oldChain.requests, (function (request) {
            if (request.id === targetRequest.id) {
              return ;
            }
            var varDeps = Belt_Array.map(request.variableDependencies, (function (varDep) {
                    var argDep = varDep.dependency;
                    var dependency;
                    switch (argDep.TAG | 0) {
                      case /* ArgumentDependency */0 :
                          var argDep$1 = argDep._0;
                          dependency = {
                            TAG: 0,
                            _0: {
                              functionFromScript: argDep$1.functionFromScript,
                              maxRecur: argDep$1.maxRecur,
                              ifMissing: argDep$1.ifMissing,
                              ifList: argDep$1.ifList,
                              fromRequestIds: Belt_Array.keep(argDep$1.fromRequestIds, (function (id) {
                                      return id !== targetRequest.id;
                                    })),
                              name: argDep$1.name
                            },
                            [Symbol.for("name")]: "ArgumentDependency"
                          };
                          break;
                      case /* Direct */1 :
                      case /* GraphQLProbe */2 :
                          dependency = argDep;
                          break;
                      
                    }
                    return {
                            name: varDep.name,
                            dependency: dependency
                          };
                  }));
            return {
                    id: request.id,
                    variableDependencies: varDeps,
                    operation: request.operation,
                    dependencyRequestIds: Belt_Array.keep(request.dependencyRequestIds, (function (id) {
                            return id !== targetRequest.id;
                          }))
                  };
          }));
    var newScript = Belt_Result.getWithDefault(Inspector.deleteRequestFunctionIfEmpty(undefined, oldChain.script, targetRequest, undefined), oldChain.script).trim();
    return {
            name: oldChain.name,
            description: oldChain.description,
            id: oldChain.id,
            script: newScript,
            scriptDependencies: oldChain.scriptDependencies,
            requests: newRequests,
            blocks: Belt_Array.keep(oldChain.blocks, (function (oldBlock) {
                    return Caml_obj.caml_notequal(oldBlock, targetRequest.operation);
                  })),
            accessToken: oldChain.accessToken,
            traceRetentionPolicy: oldChain.traceRetentionPolicy,
            yjsScript: oldChain.yjsScript
          };
  };
  var removeEdge = function (oldChain, dependencyId, targetRequestId) {
    var newRequests = Belt_Array.map(oldChain.requests, (function (request) {
            if (request.id !== targetRequestId) {
              return request;
            }
            var varDeps = Belt_Array.map(request.variableDependencies, (function (varDep) {
                    var argDep = varDep.dependency;
                    var dependency;
                    switch (argDep.TAG | 0) {
                      case /* ArgumentDependency */0 :
                          var argDep$1 = argDep._0;
                          dependency = {
                            TAG: 0,
                            _0: {
                              functionFromScript: argDep$1.functionFromScript,
                              maxRecur: argDep$1.maxRecur,
                              ifMissing: argDep$1.ifMissing,
                              ifList: argDep$1.ifList,
                              fromRequestIds: Belt_Array.keep(argDep$1.fromRequestIds, (function (id) {
                                      return id !== dependencyId;
                                    })),
                              name: argDep$1.name
                            },
                            [Symbol.for("name")]: "ArgumentDependency"
                          };
                          break;
                      case /* Direct */1 :
                      case /* GraphQLProbe */2 :
                          dependency = argDep;
                          break;
                      
                    }
                    return {
                            name: varDep.name,
                            dependency: dependency
                          };
                  }));
            return {
                    id: request.id,
                    variableDependencies: varDeps,
                    operation: request.operation,
                    dependencyRequestIds: Belt_Array.keep(request.dependencyRequestIds, (function (id) {
                            return id !== dependencyId;
                          }))
                  };
          }));
    return {
            name: oldChain.name,
            description: oldChain.description,
            id: oldChain.id,
            script: oldChain.script,
            scriptDependencies: oldChain.scriptDependencies,
            requests: newRequests,
            blocks: oldChain.blocks,
            accessToken: oldChain.accessToken,
            traceRetentionPolicy: oldChain.traceRetentionPolicy,
            yjsScript: oldChain.yjsScript
          };
  };
  var blockSearch = React.createElement(BlockSearch.make, {
        onAdd: addBlock,
        onInspect: (function (block) {
            return Curry._1(setState, (function (oldState) {
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.inspected = {
                            TAG: 1,
                            _0: block,
                            [Symbol.for("name")]: "Block"
                          };
                          return newrecord;
                        }));
          }),
        blocks: state.blocks,
        onCreate: (function (kind) {
            return Curry._1(setState, (function (oldState) {
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.blockEdit = {
                            TAG: 0,
                            _0: makeBlankBlock(kind),
                            [Symbol.for("name")]: "Create"
                          };
                          return newrecord;
                        }));
          }),
        onClose: (function (param) {
            return Curry._1(setState, (function (oldState) {
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.blockSearchOpen = false;
                          return newrecord;
                        }));
          })
      });
  var sidebar = React.createElement(Inspector.make, {
        inspected: state.inspected,
        onAddBlock: addBlock,
        onChainUpdated: (function (newChain) {
            var block = state.inspected;
            var inspected;
            switch (block.TAG | 0) {
              case /* Nothing */0 :
                  inspected = {
                    TAG: 0,
                    chain: newChain,
                    trace: state.trace,
                    [Symbol.for("name")]: "Nothing"
                  };
                  break;
              case /* Block */1 :
                  inspected = {
                    TAG: 1,
                    _0: block._0,
                    [Symbol.for("name")]: "Block"
                  };
                  break;
              case /* Request */2 :
                  var request = Belt_Option.getWithDefault(Belt_Array.getBy(newChain.requests, (function (existingRequest) {
                              return existingRequest.id === block.request.id;
                            })), block.request);
                  inspected = {
                    TAG: 2,
                    chain: newChain,
                    request: request,
                    [Symbol.for("name")]: "Request"
                  };
                  break;
              case /* RequestArgument */3 :
                  var request$1 = block.request;
                  var request$2 = Belt_Option.getWithDefault(Belt_Array.getBy(newChain.requests, (function (existingRequest) {
                              return existingRequest.id === request$1.id;
                            })), request$1);
                  inspected = {
                    TAG: 3,
                    chain: newChain,
                    request: request$2,
                    variableName: block.variableName,
                    [Symbol.for("name")]: "RequestArgument"
                  };
                  break;
              
            }
            var diagram = diagramFromChain$1(newChain);
            return Curry._1(setState, (function (oldState) {
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.inspected = inspected;
                          newrecord.chain = newChain;
                          newrecord.diagram = diagram;
                          return newrecord;
                        }));
          }),
        onReset: (function (param) {
            return Curry._1(setState, (function (oldState) {
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.inspected = {
                            TAG: 0,
                            chain: state.chain,
                            trace: state.trace,
                            [Symbol.for("name")]: "Nothing"
                          };
                          return newrecord;
                        }));
          }),
        chain: state.chain,
        schema: state.schema,
        chainExecutionResults: state.chainExecutionResults,
        onLogin: (function (service) {
            var __x = oneGraphAuth.login(service);
            __x.then(function (param) {
                  var __x = oneGraphAuth.isLoggedIn(service);
                  return __x.then(function (isLoggedIn) {
                              return Promise.resolve(isLoggedIn ? Curry._1(setMissingAuthServices, (function (oldMissingAuthServices) {
                                                  return Belt_Array.keep(oldMissingAuthServices, (function (oldService) {
                                                                return oldService !== service;
                                                              }));
                                                })) : undefined);
                            });
                });
            
          }),
        transformAndExecuteChain: (function (variables, authToken) {
            var oneGraphAuth$1 = Belt_Option.getWithDefault(Belt_Option.flatMap(authToken, (function (authToken) {
                        var tempAuth = OneGraphAuth.create({
                              appId: config.oneGraphAppId,
                              saveAuthToStorage: false
                            });
                        Belt_Option.forEach(tempAuth, (function (tempAuth) {
                                var accessToken = {
                                  accessToken: authToken
                                };
                                tempAuth.setToken(accessToken);
                                
                              }));
                        return tempAuth;
                      })), oneGraphAuth);
            var __x = Inspector.transformAndExecuteChain(state.chain, schema, oneGraphAuth$1, variables);
            __x.then(function (result) {
                  return Promise.resolve(Curry._1(setState, (function (oldState) {
                                    var newTrace = Belt_Option.map(oldState.chain.id, (function (chainId) {
                                            result.id = Uuid.v4();
                                            return {
                                                    chainId: chainId,
                                                    createdAt: new Date().toUTCString(),
                                                    trace: result,
                                                    variables: variables
                                                  };
                                          }));
                                    Belt_Option.forEach(newTrace, Chain.Trace.saveToLocalStorage);
                                    var newrecord = Caml_obj.caml_obj_dup(oldState);
                                    newrecord.trace = newTrace;
                                    newrecord.requestValueCache = chainResultToRequestValueCache(result);
                                    newrecord.chainExecutionResults = result;
                                    return newrecord;
                                  })));
                });
            
          }),
        onPersistChain: (function (authToken) {
            persistChain(config, schema, authToken, state.chain, (function (docId) {
                    return Curry._1(setState, (function (oldState) {
                                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                                  newrecord.savedChainId = docId;
                                  return newrecord;
                                }));
                  }));
            
          }),
        savedChainId: state.savedChainId,
        onRequestCodeInspected: (function (request) {
            var names = Chain.requestScriptNames(request);
            var functionName = names.functionName;
            var source = state.chain.script;
            var sourceFile = Typescript.createSourceFile("main.ts", source, 99, true);
            var pos = TypeScript.findFnPos(sourceFile, functionName);
            return Belt_Option.forEach(pos, (function (param) {
                          var end = param.end;
                          var start = param.start;
                          return Belt_Option.forEach(state.scriptEditor.editor, (function (editor) {
                                        var model = editor.getModel("file://main.tsx");
                                        var start$1 = model.getPositionAt(start);
                                        var end$1 = model.getPositionAt(end);
                                        editor.revealLineInCenter(start$1.lineNumber, 1);
                                        editor.setSelection({
                                              startLineNumber: start$1.lineNumber,
                                              startColumn: start$1.column,
                                              endLineNumber: end$1.lineNumber,
                                              endColumn: end$1.column
                                            });
                                        
                                      }));
                        }));
          }),
        onExecuteRequest: onExecuteRequest,
        requestValueCache: state.requestValueCache,
        onDeleteRequest: (function (targetRequest) {
            return Curry._1(setState, (function (oldState) {
                          var newChain = removeRequest(oldState.chain, targetRequest);
                          var diagram = diagramFromChain$1(newChain);
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.inspected = {
                            TAG: 0,
                            chain: newChain,
                            trace: state.trace,
                            [Symbol.for("name")]: "Nothing"
                          };
                          newrecord.chain = newChain;
                          newrecord.diagram = diagram;
                          return newrecord;
                        }));
          }),
        onDeleteEdge: (function (targetRequestId, dependencyId) {
            return Curry._1(setState, (function (oldState) {
                          var newChain = removeEdge(oldState.chain, dependencyId, targetRequestId);
                          var diagram = diagramFromChain$1(newChain);
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.inspected = {
                            TAG: 0,
                            chain: newChain,
                            trace: state.trace,
                            [Symbol.for("name")]: "Nothing"
                          };
                          newrecord.chain = newChain;
                          newrecord.diagram = diagram;
                          return newrecord;
                        }));
          }),
        onRequestInspected: onRequestInspected,
        oneGraphAuth: oneGraphAuth,
        onDragStart: (function (connectionDrag) {
            return Curry._1(setState, (function (oldState) {
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.connectionDrag = connectionDrag;
                          return newrecord;
                        }));
          }),
        trace: state.trace,
        initialChain: initialChain,
        onSaveChain: onSaveChain,
        onClose: onClose,
        appId: config.oneGraphAppId,
        onPotentialVariableSourceConnect: onPotentialVariableSourceConnect,
        authTokens: Belt_Array.keepMap([Belt_Option.map(config.chainAccessToken, (function (token) {
                      var fullLength = token.length;
                      var starLength = Math.max(0, fullLength - 4 | 0);
                      var stars = "*".repeat(starLength);
                      var last4 = token.substring(starLength, fullLength);
                      var displayedToken = stars + last4;
                      return {
                              accessToken: token,
                              displayedToken: displayedToken,
                              name: displayedToken
                            };
                    }))], (function (x) {
                return x;
              })),
        onStartAudio: (function (param) {
            console.log("Should start audio now");
            return Belt_Option.forEach($$Navigator.$$MediaDevices.getUserAudio(undefined), (function (promise) {
                          var __x = promise.then(function (stream) {
                                Curry._1(setState, (function (oldState) {
                                        var newrecord = Caml_obj.caml_obj_dup(oldState);
                                        newrecord.audioStream = {
                                          _0: stream,
                                          [Symbol.for("name")]: "Loaded"
                                        };
                                        return newrecord;
                                      }));
                                return Promise.resolve((console.log("Got stream: ", stream), undefined));
                              });
                          __x.catch(function (err) {
                                return Promise.resolve((console.warn("Unable to get audio stream: ", err), undefined));
                              });
                          
                        }));
          }),
        audioLevel: state.audioLevel
      });
  var tmp = {
    schema: state.schema,
    chain: state.chain,
    onChange: (function (newScript) {
        try {
          var init = state.chain;
          var newChain_name = init.name;
          var newChain_description = init.description;
          var newChain_id = init.id;
          var newChain_scriptDependencies = init.scriptDependencies;
          var newChain_requests = init.requests;
          var newChain_blocks = init.blocks;
          var newChain_accessToken = init.accessToken;
          var newChain_traceRetentionPolicy = init.traceRetentionPolicy;
          var newChain_yjsScript = init.yjsScript;
          var newChain = {
            name: newChain_name,
            description: newChain_description,
            id: newChain_id,
            script: newScript,
            scriptDependencies: newChain_scriptDependencies,
            requests: newChain_requests,
            blocks: newChain_blocks,
            accessToken: newChain_accessToken,
            traceRetentionPolicy: newChain_traceRetentionPolicy,
            yjsScript: newChain_yjsScript
          };
          var functionNames = [];
          var block = state.inspected;
          var inspected;
          switch (block.TAG | 0) {
            case /* Nothing */0 :
                inspected = {
                  TAG: 0,
                  chain: newChain,
                  trace: state.trace,
                  [Symbol.for("name")]: "Nothing"
                };
                break;
            case /* Block */1 :
                inspected = {
                  TAG: 1,
                  _0: block._0,
                  [Symbol.for("name")]: "Block"
                };
                break;
            case /* Request */2 :
                var request = Belt_Option.getWithDefault(Belt_Array.getBy(newChain_requests, (function (existingRequest) {
                            return existingRequest.id === block.request.id;
                          })), block.request);
                inspected = {
                  TAG: 2,
                  chain: newChain,
                  request: request,
                  [Symbol.for("name")]: "Request"
                };
                break;
            case /* RequestArgument */3 :
                var request$1 = block.request;
                var request$2 = Belt_Option.getWithDefault(Belt_Array.getBy(newChain_requests, (function (existingRequest) {
                            return existingRequest.id === request$1.id;
                          })), request$1);
                inspected = {
                  TAG: 3,
                  chain: newChain,
                  request: request$2,
                  variableName: block.variableName,
                  [Symbol.for("name")]: "RequestArgument"
                };
                break;
            
          }
          return Curry._1(setState, (function (oldState) {
                        var newrecord = Caml_obj.caml_obj_dup(oldState);
                        newrecord.inspected = inspected;
                        newrecord.scriptFunctions = functionNames;
                        newrecord.chain = newChain;
                        return newrecord;
                      }));
        }
        catch (raw_err){
          var err = Caml_js_exceptions.internalToOCamlException(raw_err);
          console.error("Error updating script from editor: ", err);
          return ;
        }
      }),
    onMount: (function (editor, monaco) {
        return Curry._1(setState, (function (oldState) {
                      var newrecord = Caml_obj.caml_obj_dup(oldState);
                      var init = oldState.scriptEditor;
                      newrecord.scriptEditor = {
                        isOpen: init.isOpen,
                        editor: Caml_option.some(editor),
                        monaco: Caml_option.some(monaco)
                      };
                      return newrecord;
                    }));
      }),
    onPotentialScriptSourceConnect: (function (sourceRequest, sourceDom, scriptPosition, param) {
        var y = param[1];
        var x = param[0];
        return Curry._1(setState, (function (oldState) {
                      var connectionDrag_2 = {
                        TAG: 1,
                        scriptPosition: scriptPosition,
                        [Symbol.for("name")]: "Script"
                      };
                      var connectionDrag_3 = [
                        x,
                        y
                      ];
                      var connectionDrag = {
                        TAG: 3,
                        sourceRequest: sourceRequest,
                        sourceDom: sourceDom,
                        target: connectionDrag_2,
                        windowPosition: connectionDrag_3,
                        [Symbol.for("name")]: "Completed"
                      };
                      var newrecord = Caml_obj.caml_obj_dup(oldState);
                      newrecord.connectionDrag = connectionDrag;
                      return newrecord;
                    }));
      }),
    onSaveChain: onSaveChain,
    insight: {
      TAG: 0,
      _0: state.insight,
      [Symbol.for("name")]: "Ok"
    }
  };
  var tmp$1 = state.scriptEditor.isOpen ? undefined : "none";
  if (tmp$1 !== undefined) {
    tmp.className = Caml_option.valFromOption(tmp$1);
  }
  var match$3 = state.blockEdit;
  var tmp$2;
  if (typeof match$3 === "number") {
    tmp$2 = null;
  } else {
    var isCreateAction;
    isCreateAction = typeof match$3 === "number" || match$3.TAG !== /* Create */0 ? false : true;
    var editor = React.createElement(BlockEditor.make, {
          schema: state.schema,
          block: match$3._0,
          onClose: (function (param) {
              return Curry._1(setState, (function (oldState) {
                            var newrecord = Caml_obj.caml_obj_dup(oldState);
                            newrecord.blockEdit = /* Nothing */0;
                            return newrecord;
                          }));
            }),
          onSave: (function (initial, superBlock) {
              var ast = Graphql.parse(superBlock.body);
              var initialAst = Caml_array.get(Graphql.parse(initial.body).definitions, 0);
              var newOperationDefinitionCount = Belt_Array.keep(ast.definitions, (function (definition) {
                      var match = definition.kind;
                      switch (match) {
                        case "FragmentDefinition" :
                        case "ObjectTypeDefinition" :
                            return false;
                        default:
                          return true;
                      }
                    })).length;
              var guessedInitialBlock = {
                contents: undefined
              };
              var blocks = Belt_Array.mapWithIndex(ast.definitions, (function (_idx, definition) {
                      var match = definition.kind;
                      var kind;
                      switch (match) {
                        case "FragmentDefinition" :
                            kind = "fragment";
                            break;
                        case "ObjectTypeDefinition" :
                            kind = "objectType";
                            break;
                        default:
                          kind = definition.operation;
                      }
                      var definition$1;
                      if (kind === "objectType") {
                        var compiled = GraphQLJs.Mock.compileComputeToIdentityQuery(definition);
                        Debug.assignToWindowForDeveloperDebug("computedCompiled", [
                              definition,
                              compiled
                            ]);
                        definition$1 = compiled;
                      } else {
                        definition$1 = definition;
                      }
                      var sameNameAsInitial = initialAst.name.value === definition$1.name.value;
                      var match$1 = initial.kind;
                      var sameOperationKindChanged = newOperationDefinitionCount !== 0 ? (
                          newOperationDefinitionCount !== 1 ? false : kind !== "fragment"
                        ) : (
                          match$1 !== 3 ? false : kind === "fragment"
                        );
                      var sameOperationAsInitial = sameNameAsInitial || sameOperationKindChanged ? true : false;
                      var services = Belt_Array.map(GraphQLUtils.gatherAllReferencedServices(schema, definition$1), (function (service) {
                              return service.slug;
                            }));
                      var blank = makeBlankBlock("query");
                      var title = Belt_Option.getWithDefault(definition$1.name.value, "Untitled");
                      var block_id = sameOperationAsInitial ? initial.id : Uuid.v4();
                      var block_description = blank.description;
                      var block_body = Graphql.print(definition$1);
                      var block_kind = kind === "query" ? /* Query */0 : (
                          kind === "mutation" ? /* Mutation */1 : (
                              kind === "fragment" ? /* Fragment */3 : (
                                  kind === "subscription" ? /* Subscription */2 : /* Compute */4
                                )
                            )
                        );
                      var block_contributedBy = blank.contributedBy;
                      var block = {
                        id: block_id,
                        title: title,
                        description: block_description,
                        body: block_body,
                        kind: block_kind,
                        contributedBy: block_contributedBy,
                        services: services
                      };
                      if (sameNameAsInitial || sameOperationKindChanged) {
                        guessedInitialBlock.contents = block;
                      }
                      return block;
                    }));
              try {
                return Curry._1(setState, (function (oldState) {
                              var newChain = Belt_Array.reduce(blocks, oldState.chain, (function (newChain, block) {
                                      var match = block.kind;
                                      if (match === 3) {
                                        return {
                                                name: newChain.name,
                                                description: newChain.description,
                                                id: newChain.id,
                                                script: newChain.script,
                                                scriptDependencies: newChain.scriptDependencies,
                                                requests: newChain.requests,
                                                blocks: Belt_Array.concat(Belt_Array.keep(newChain.blocks, (function (existingBlock) {
                                                            return Caml_obj.caml_notequal(existingBlock.id, block.id);
                                                          })), [block]),
                                                accessToken: newChain.accessToken,
                                                traceRetentionPolicy: newChain.traceRetentionPolicy,
                                                yjsScript: newChain.yjsScript
                                              };
                                      }
                                      var isLikelyInitialBlock = Caml_obj.caml_equal(block, guessedInitialBlock.contents);
                                      var initialReq = isLikelyInitialBlock ? Belt_Array.getBy(newChain.requests, (function (request) {
                                                return Caml_obj.caml_equal(request.operation.id, initial.id);
                                              })) : undefined;
                                      var doc = Graphql.parse(block.body);
                                      var definition = Caml_array.get(doc.definitions, 0);
                                      var variableNames = GraphQLUtils.getOperationVariables(definition);
                                      var variableDependencies = Belt_Array.map(variableNames, (function (param) {
                                              var variableName = param[0];
                                              var existingVarDep = Belt_Option.flatMap(initialReq, (function (request) {
                                                      return Belt_Array.getBy(request.variableDependencies, (function (existingVariableDependency) {
                                                                    return existingVariableDependency.name === variableName;
                                                                  }));
                                                    }));
                                              var variableDep = {
                                                TAG: 1,
                                                _0: {
                                                  name: variableName,
                                                  value: {
                                                    TAG: 1,
                                                    _0: variableName,
                                                    [Symbol.for("name")]: "Variable"
                                                  }
                                                },
                                                [Symbol.for("name")]: "Direct"
                                              };
                                              return Belt_Option.getWithDefault(existingVarDep, {
                                                          name: variableName,
                                                          dependency: variableDep
                                                        });
                                            }));
                                      var newReq_id = block.title;
                                      var newReq_dependencyRequestIds = Belt_Option.mapWithDefault(initialReq, [], (function (req) {
                                              return req.dependencyRequestIds;
                                            }));
                                      var newReq = {
                                        id: newReq_id,
                                        variableDependencies: variableDependencies,
                                        operation: block,
                                        dependencyRequestIds: newReq_dependencyRequestIds
                                      };
                                      var returnProperties = Belt_Array.keepMap(variableDependencies, (function (varDep) {
                                              var match = varDep.dependency;
                                              switch (match.TAG | 0) {
                                                case /* ArgumentDependency */0 :
                                                    return [
                                                            varDep.name,
                                                            varDep.name
                                                          ];
                                                case /* Direct */1 :
                                                case /* GraphQLProbe */2 :
                                                    return ;
                                                
                                              }
                                            }));
                                      var newScript = Inspector.ensureRequestFunctionExists(undefined, returnProperties, newChain.script, newReq, undefined);
                                      var newChain_name = newChain.name;
                                      var newChain_description = newChain.description;
                                      var newChain_id = newChain.id;
                                      var newChain_scriptDependencies = newChain.scriptDependencies;
                                      var newChain_requests = Belt_Array.concat(Belt_Array.keep(newChain.requests, (function (existingRequest) {
                                                  return Belt_Option.mapWithDefault(initialReq, true, (function (initialReq) {
                                                                return existingRequest.id !== initialReq.id;
                                                              }));
                                                })), [newReq]);
                                      var newChain_blocks = Belt_Array.concat(Belt_Array.keep(newChain.blocks, (function (existingBlock) {
                                                  return Caml_obj.caml_notequal(existingBlock.id, block.id);
                                                })), [block]);
                                      var newChain_accessToken = newChain.accessToken;
                                      var newChain_traceRetentionPolicy = newChain.traceRetentionPolicy;
                                      var newChain_yjsScript = newChain.yjsScript;
                                      var newChain$1 = {
                                        name: newChain_name,
                                        description: newChain_description,
                                        id: newChain_id,
                                        script: newScript,
                                        scriptDependencies: newChain_scriptDependencies,
                                        requests: newChain_requests,
                                        blocks: newChain_blocks,
                                        accessToken: newChain_accessToken,
                                        traceRetentionPolicy: newChain_traceRetentionPolicy,
                                        yjsScript: newChain_yjsScript
                                      };
                                      var match$1 = Chain.monacoTypelibForChain(schema, newChain$1);
                                      var importLine = match$1.importLine;
                                      var hasImport = Belt_Option.isSome(Caml_option.null_to_opt(newScript.match(new RegExp("import[\\s\\S.]+from[\\s\\S]+'oneGraphStudio';"))));
                                      var newScript$1 = hasImport ? newScript.replace(new RegExp("import[\\s\\S.]+from[\\s\\S]+'oneGraphStudio';"), importLine) : importLine + "\n\n" + newScript;
                                      return {
                                              name: newChain_name,
                                              description: newChain_description,
                                              id: newChain_id,
                                              script: newScript$1,
                                              scriptDependencies: newChain_scriptDependencies,
                                              requests: newChain_requests,
                                              blocks: newChain_blocks,
                                              accessToken: newChain_accessToken,
                                              traceRetentionPolicy: newChain_traceRetentionPolicy,
                                              yjsScript: newChain_yjsScript
                                            };
                                    }));
                              var newInitialBlock = Belt_Option.getWithDefault(Belt_Array.getBy(newChain.blocks, (function (block) {
                                          return Caml_obj.caml_equal(block.id, initial.id);
                                        })), Caml_array.get(blocks, 0));
                              var inspected;
                              if (isCreateAction) {
                                var request = Belt_Array.getBy(newChain.requests, (function (req) {
                                        return Caml_obj.caml_equal(req.operation.id, newInitialBlock.id);
                                      }));
                                inspected = Belt_Option.mapWithDefault(request, {
                                      TAG: 0,
                                      chain: newChain,
                                      trace: state.trace,
                                      [Symbol.for("name")]: "Nothing"
                                    }, (function (request) {
                                        var newRequest_id = request.id;
                                        var newRequest_variableDependencies = request.variableDependencies;
                                        var newRequest_dependencyRequestIds = request.dependencyRequestIds;
                                        var newRequest = {
                                          id: newRequest_id,
                                          variableDependencies: newRequest_variableDependencies,
                                          operation: newInitialBlock,
                                          dependencyRequestIds: newRequest_dependencyRequestIds
                                        };
                                        return {
                                                TAG: 2,
                                                chain: newChain,
                                                request: newRequest,
                                                [Symbol.for("name")]: "Request"
                                              };
                                      }));
                              } else {
                                var match = oldState.inspected;
                                switch (match.TAG | 0) {
                                  case /* Nothing */0 :
                                      inspected = {
                                        TAG: 0,
                                        chain: newChain,
                                        trace: state.trace,
                                        [Symbol.for("name")]: "Nothing"
                                      };
                                      break;
                                  case /* Block */1 :
                                      inspected = {
                                        TAG: 1,
                                        _0: newInitialBlock,
                                        [Symbol.for("name")]: "Block"
                                      };
                                      break;
                                  case /* Request */2 :
                                      var request$1 = match.request;
                                      var newRequest_id = request$1.id;
                                      var newRequest_variableDependencies = request$1.variableDependencies;
                                      var newRequest_dependencyRequestIds = request$1.dependencyRequestIds;
                                      var newRequest = {
                                        id: newRequest_id,
                                        variableDependencies: newRequest_variableDependencies,
                                        operation: newInitialBlock,
                                        dependencyRequestIds: newRequest_dependencyRequestIds
                                      };
                                      inspected = {
                                        TAG: 2,
                                        chain: newChain,
                                        request: newRequest,
                                        [Symbol.for("name")]: "Request"
                                      };
                                      break;
                                  case /* RequestArgument */3 :
                                      var request$2 = match.request;
                                      var newRequest_id$1 = request$2.id;
                                      var newRequest_variableDependencies$1 = request$2.variableDependencies;
                                      var newRequest_dependencyRequestIds$1 = request$2.dependencyRequestIds;
                                      var newRequest$1 = {
                                        id: newRequest_id$1,
                                        variableDependencies: newRequest_variableDependencies$1,
                                        operation: newInitialBlock,
                                        dependencyRequestIds: newRequest_dependencyRequestIds$1
                                      };
                                      inspected = {
                                        TAG: 3,
                                        chain: newChain,
                                        request: newRequest$1,
                                        variableName: match.variableName,
                                        [Symbol.for("name")]: "RequestArgument"
                                      };
                                      break;
                                  
                                }
                              }
                              var allBlocks = Belt_Array.concat(oldState.blocks, blocks);
                              var diagram = diagramFromChain$1(newChain);
                              var newrecord = Caml_obj.caml_obj_dup(oldState);
                              newrecord.blockEdit = /* Nothing */0;
                              newrecord.inspected = inspected;
                              newrecord.blocks = allBlocks;
                              newrecord.chain = newChain;
                              newrecord.diagram = diagram;
                              return newrecord;
                            }));
              }
              catch (exn){
                return ;
              }
            }),
          availableFragments: availableFragments
        });
    tmp$2 = React.createElement(Comps.Modal.make, {
          children: editor
        });
  }
  var dragInfo = state.connectionDrag;
  var tmp$3;
  if (typeof dragInfo === "number") {
    tmp$3 = null;
  } else {
    switch (dragInfo.TAG | 0) {
      case /* StartedSource */0 :
          tmp$3 = React.createElement(ChainEditor$ConnectorLine, {
                source: dragInfo.sourceDom,
                onDragEnd: (function (param) {
                    return Curry._1(setState, (function (oldState) {
                                  var newrecord = Caml_obj.caml_obj_dup(oldState);
                                  newrecord.connectionDrag = /* Empty */0;
                                  return newrecord;
                                }));
                  }),
                invert: false
              });
          break;
      case /* StartedTarget */1 :
          switch (dragInfo.target.TAG | 0) {
            case /* Variable */0 :
                tmp$3 = React.createElement(ChainEditor$ConnectorLine, {
                      source: dragInfo.sourceDom,
                      onDragEnd: (function (param) {
                          return Curry._1(setState, (function (oldState) {
                                        var newrecord = Caml_obj.caml_obj_dup(oldState);
                                        newrecord.connectionDrag = /* Empty */0;
                                        return newrecord;
                                      }));
                        }),
                      invert: true
                    });
                break;
            case /* Script */1 :
                tmp$3 = null;
                break;
            case /* Input */2 :
                Curry._1(setState, (function (oldState) {
                        var newrecord = Caml_obj.caml_obj_dup(oldState);
                        newrecord.connectionDrag = /* Empty */0;
                        return newrecord;
                      }));
                tmp$3 = null;
                break;
            
          }
          break;
      case /* CompletedPendingVariable */2 :
          var match$4 = dragInfo.windowPosition;
          var y = match$4[1];
          var x = match$4[0];
          var targetRequest = dragInfo.targetRequest;
          var variableDependencies = Belt_SortArray.stableSortBy(targetRequest.variableDependencies, (function (a, b) {
                  return $$String.compare(a.name, b.name);
                }));
          var onClick = function (variableDependency) {
            var connectionDrag;
            if (variableDependency !== undefined) {
              var variableTarget = {
                targetRequest: targetRequest,
                variableDependency: variableDependency
              };
              connectionDrag = {
                TAG: 3,
                sourceRequest: dragInfo.sourceRequest,
                sourceDom: dragInfo.sourceDom,
                target: {
                  TAG: 0,
                  _0: variableTarget,
                  [Symbol.for("name")]: "Variable"
                },
                windowPosition: [
                  x,
                  y
                ],
                [Symbol.for("name")]: "Completed"
              };
            } else {
              connectionDrag = /* Empty */0;
            }
            return Curry._1(setState, (function (oldState) {
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.connectionDrag = connectionDrag;
                          return newrecord;
                        }));
          };
          tmp$3 = React.createElement(ChainEditor$PopupPicker, {
                top: y,
                left: x,
                children: null,
                onClose: (function (param) {
                    return onClick(undefined);
                  })
              }, React.createElement("span", {
                    style: {
                      color: Comps.colors["gray-2"]
                    }
                  }, "Choose destination variable: "), React.createElement("ul", undefined, Belt_Array.map(variableDependencies, (function (variableDependency) {
                          return React.createElement("li", {
                                      key: variableDependency.name,
                                      className: "cursor-pointer graphql-structure-preview-entry",
                                      onClick: (function (param) {
                                          return onClick(variableDependency);
                                        })
                                    }, "$" + variableDependency.name);
                        }))));
          break;
      case /* Completed */3 :
          var variabletarget = dragInfo.target;
          var sourceDom = dragInfo.sourceDom;
          var sourceRequest = dragInfo.sourceRequest;
          switch (variabletarget.TAG | 0) {
            case /* Variable */0 :
                var windowPosition = dragInfo.windowPosition;
                var variabletarget$1 = variabletarget._0;
                var targetVariableDependency = variabletarget$1.variableDependency;
                var targetRequest$1 = variabletarget$1.targetRequest;
                var chainFragmentsDoc = Belt_Array.keepMap(state.chain.blocks, (function (block) {
                          var match = block.kind;
                          if (match !== 3) {
                            return ;
                          } else {
                            return block.body;
                          }
                        })).join("\n\n");
                var parsedOperation = Graphql.parse(sourceRequest.operation.body);
                var definition = Belt_Array.getExn(parsedOperation.definitions, 0);
                var targetParsedOperation = Graphql.parse(targetRequest$1.operation.body);
                var targetDefinition = Belt_Array.getExn(targetParsedOperation.definitions, 0);
                var targetVariables = GraphQLUtils.getOperationVariables(targetDefinition);
                var targetVariableType = Belt_Option.map(Belt_Array.getBy(targetVariables, (function (param) {
                            return targetVariableDependency.name === param[0];
                          })), (function (param) {
                        return param[1];
                      }));
                var onClose$1 = function (param) {
                  return Curry._1(setState, (function (oldState) {
                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                newrecord.connectionDrag = /* Empty */0;
                                return newrecord;
                              }));
                };
                var tmp$4 = {
                  requestId: sourceRequest.id,
                  schema: schema,
                  definition: definition,
                  fragmentDefinitions: GraphQLJs.Mock.gatherFragmentDefinitions({
                        operationDoc: chainFragmentsDoc
                      }),
                  onCopy: (function (param) {
                      var path = param.path;
                      var printedType = param.printedType;
                      var dataPath = Belt_Array.concat(["payload"], path);
                      var nullableTargetVariableType = Belt_Option.map(targetVariableType, (function (typ) {
                              return typ.replace(new RegExp("!", "g"), "");
                            }));
                      var nullablePrintedType = printedType.replace(new RegExp("!", "g"), "");
                      var match = nullablePrintedType.toLocaleLowerCase();
                      var match$1 = Belt_Option.map(nullableTargetVariableType, (function (prim) {
                              return prim.toLocaleLowerCase();
                            }));
                      var typesMatch;
                      var exit = 0;
                      var exit$1 = 0;
                      if (match$1 !== undefined && match === match$1) {
                        typesMatch = true;
                      } else {
                        exit$1 = 2;
                      }
                      if (exit$1 === 2) {
                        switch (match) {
                          case "float" :
                              if (match$1 !== undefined) {
                                if (match$1 === "int") {
                                  typesMatch = true;
                                } else {
                                  exit = 1;
                                }
                              } else {
                                typesMatch = false;
                              }
                              break;
                          case "id" :
                              if (match$1 !== undefined) {
                                if (match$1 === "string") {
                                  typesMatch = true;
                                } else {
                                  exit = 1;
                                }
                              } else {
                                typesMatch = false;
                              }
                              break;
                          case "int" :
                              if (match$1 !== undefined) {
                                if (match$1 === "float") {
                                  typesMatch = true;
                                } else {
                                  exit = 1;
                                }
                              } else {
                                typesMatch = false;
                              }
                              break;
                          case "json" :
                              typesMatch = true;
                              break;
                          case "string" :
                              if (match$1 !== undefined) {
                                if (match$1 === "id") {
                                  typesMatch = true;
                                } else {
                                  exit = 1;
                                }
                              } else {
                                typesMatch = false;
                              }
                              break;
                          default:
                            exit = 1;
                        }
                      }
                      if (exit === 1) {
                        typesMatch = match$1 === "json" ? true : false;
                      }
                      if (typesMatch) {
                        return Curry._1(setState, (function (oldState) {
                                      var potentialProbeDependency = {
                                        TAG: 2,
                                        _0: {
                                          name: targetVariableDependency.name,
                                          ifMissing: "SKIP",
                                          ifList: "FIRST",
                                          fromRequestId: sourceRequest.id,
                                          path: dataPath,
                                          functionFromScript: "TBD"
                                        },
                                        [Symbol.for("name")]: "GraphQLProbe"
                                      };
                                      var newRequests = Belt_Array.map(oldState.chain.requests, (function (request) {
                                              if (targetRequest$1.id !== request.id) {
                                                return request;
                                              }
                                              var varDeps = Belt_Array.map(request.variableDependencies, (function (varDep) {
                                                      if (varDep.name === targetVariableDependency.name) {
                                                        return {
                                                                name: varDep.name,
                                                                dependency: potentialProbeDependency
                                                              };
                                                      }
                                                      var argDep = varDep.dependency;
                                                      var dependency;
                                                      switch (argDep.TAG | 0) {
                                                        case /* ArgumentDependency */0 :
                                                            var argDep$1 = argDep._0;
                                                            var newArgDep_functionFromScript = argDep$1.functionFromScript;
                                                            var newArgDep_maxRecur = argDep$1.maxRecur;
                                                            var newArgDep_ifMissing = argDep$1.ifMissing;
                                                            var newArgDep_ifList = argDep$1.ifList;
                                                            var newArgDep_fromRequestIds = Utils.$$String.distinctStrings(Belt_Array.concat(argDep$1.fromRequestIds, [sourceRequest.id]));
                                                            var newArgDep_name = argDep$1.name;
                                                            var newArgDep = {
                                                              functionFromScript: newArgDep_functionFromScript,
                                                              maxRecur: newArgDep_maxRecur,
                                                              ifMissing: newArgDep_ifMissing,
                                                              ifList: newArgDep_ifList,
                                                              fromRequestIds: newArgDep_fromRequestIds,
                                                              name: newArgDep_name
                                                            };
                                                            dependency = {
                                                              TAG: 0,
                                                              _0: newArgDep,
                                                              [Symbol.for("name")]: "ArgumentDependency"
                                                            };
                                                            break;
                                                        case /* Direct */1 :
                                                        case /* GraphQLProbe */2 :
                                                            dependency = argDep;
                                                            break;
                                                        
                                                      }
                                                      return {
                                                              name: varDep.name,
                                                              dependency: dependency
                                                            };
                                                    }));
                                              return {
                                                      id: request.id,
                                                      variableDependencies: varDeps,
                                                      operation: request.operation,
                                                      dependencyRequestIds: Utils.$$String.distinctStrings(Belt_Array.concat(request.dependencyRequestIds, [sourceRequest.id]))
                                                    };
                                            }));
                                      var newScript = Belt_Result.getWithDefault(Inspector.deleteRequestFunctionIfEmpty(undefined, oldState.chain.script, targetRequest$1, undefined), oldState.chain.script).trim();
                                      var init = oldState.chain;
                                      var newChain_name = init.name;
                                      var newChain_description = init.description;
                                      var newChain_id = init.id;
                                      var newChain_scriptDependencies = init.scriptDependencies;
                                      var newChain_blocks = init.blocks;
                                      var newChain_accessToken = init.accessToken;
                                      var newChain_traceRetentionPolicy = init.traceRetentionPolicy;
                                      var newChain_yjsScript = init.yjsScript;
                                      var newChain = {
                                        name: newChain_name,
                                        description: newChain_description,
                                        id: newChain_id,
                                        script: newScript,
                                        scriptDependencies: newChain_scriptDependencies,
                                        requests: newRequests,
                                        blocks: newChain_blocks,
                                        accessToken: newChain_accessToken,
                                        traceRetentionPolicy: newChain_traceRetentionPolicy,
                                        yjsScript: newChain_yjsScript
                                      };
                                      var diagram = diagramFromChain$1(newChain);
                                      var newTargetRequest = Belt_Array.getBy(newRequests, (function (request) {
                                              return targetRequest$1.id === request.id;
                                            }));
                                      var inspected = Belt_Option.mapWithDefault(newTargetRequest, oldState.inspected, (function (newTargetRequest) {
                                              var match = oldState.inspected;
                                              if (match.TAG === /* Request */2 && match.request.id === newTargetRequest.id) {
                                                return {
                                                        TAG: 2,
                                                        chain: newChain,
                                                        request: newTargetRequest,
                                                        [Symbol.for("name")]: "Request"
                                                      };
                                              } else {
                                                return oldState.inspected;
                                              }
                                            }));
                                      var newrecord = Caml_obj.caml_obj_dup(oldState);
                                      newrecord.connectionDrag = /* Empty */0;
                                      newrecord.inspected = inspected;
                                      newrecord.chain = newChain;
                                      newrecord.diagram = diagram;
                                      return newrecord;
                                    }));
                      } else {
                        return Curry._1(setState, (function (oldState) {
                                      var parsed;
                                      try {
                                        parsed = Caml_option.some(Typescript.createSourceFile("main.ts", oldState.chain.script, 99, true));
                                      }
                                      catch (exn){
                                        parsed = undefined;
                                      }
                                      var newConnectionDrag = Belt_Option.map(parsed, (function (parsed) {
                                              var fnTypes = TypeScript.findFunctionTypes(parsed);
                                              var existingFnMatches = Belt_SortArray.stableSortBy(Belt_Array.keep(Js_dict.values(fnTypes), (function (param) {
                                                          var match = nullablePrintedType.toLocaleLowerCase();
                                                          var match$1 = Belt_Option.map(param.firstParamType, (function (prim) {
                                                                  return prim.toLocaleLowerCase();
                                                                }));
                                                          var firstParamMatches;
                                                          if (match$1 !== undefined) {
                                                            if (match === match$1) {
                                                              firstParamMatches = true;
                                                            } else {
                                                              var exit = 0;
                                                              switch (match) {
                                                                case "id" :
                                                                    firstParamMatches = match$1 === "string" ? true : false;
                                                                    break;
                                                                case "float" :
                                                                case "int" :
                                                                    exit = 1;
                                                                    break;
                                                                default:
                                                                  firstParamMatches = false;
                                                              }
                                                              if (exit === 1) {
                                                                firstParamMatches = match$1 === "number" ? true : false;
                                                              }
                                                              
                                                            }
                                                          } else {
                                                            firstParamMatches = false;
                                                          }
                                                          var match$2 = Belt_Option.map(nullableTargetVariableType, (function (prim) {
                                                                  return prim.toLocaleLowerCase();
                                                                }));
                                                          var match$3 = Belt_Option.map(param.returnType, (function (prim) {
                                                                  return prim.toLocaleLowerCase();
                                                                }));
                                                          var returnTypeMatches;
                                                          if (match$2 !== undefined && match$3 !== undefined) {
                                                            if (match$2 === match$3) {
                                                              returnTypeMatches = true;
                                                            } else {
                                                              var exit$1 = 0;
                                                              switch (match$2) {
                                                                case "id" :
                                                                    returnTypeMatches = match$3 === "string" ? true : false;
                                                                    break;
                                                                case "float" :
                                                                case "int" :
                                                                    exit$1 = 1;
                                                                    break;
                                                                default:
                                                                  returnTypeMatches = false;
                                                              }
                                                              if (exit$1 === 1) {
                                                                returnTypeMatches = match$3 === "number" ? true : false;
                                                              }
                                                              
                                                            }
                                                          } else {
                                                            returnTypeMatches = false;
                                                          }
                                                          if (firstParamMatches) {
                                                            return returnTypeMatches;
                                                          } else {
                                                            return false;
                                                          }
                                                        })), (function (a, b) {
                                                      return $$String.compare(a.name, b.name);
                                                    }));
                                              return {
                                                      TAG: 4,
                                                      sourceRequest: sourceRequest,
                                                      sourceDom: sourceDom,
                                                      variableTarget: variabletarget$1,
                                                      sourceType: printedType,
                                                      targetVariableType: targetVariableType,
                                                      windowPosition: windowPosition,
                                                      potentialFunctionMatches: existingFnMatches,
                                                      dataPath: dataPath,
                                                      path: path,
                                                      [Symbol.for("name")]: "CompletedWithTypeMismatch"
                                                    };
                                            }));
                                      var newrecord = Caml_obj.caml_obj_dup(oldState);
                                      newrecord.connectionDrag = Belt_Option.getWithDefault(newConnectionDrag, /* Empty */0);
                                      return newrecord;
                                    }));
                      }
                    }),
                  onClose: (function (param) {
                      return Curry._1(setState, (function (oldState) {
                                    var newrecord = Caml_obj.caml_obj_dup(oldState);
                                    newrecord.connectionDrag = /* Empty */0;
                                    return newrecord;
                                  }));
                    }),
                  definitionResultData: definitionResultData
                };
                if (targetVariableType !== undefined) {
                  tmp$4.targetGqlType = Caml_option.valFromOption(targetVariableType);
                }
                tmp$3 = React.createElement(ChainEditor$PopupPicker, {
                      top: windowPosition[1],
                      left: windowPosition[0],
                      children: React.createElement(Inspector.GraphQLPreview.make, tmp$4),
                      onClose: onClose$1
                    });
                break;
            case /* Script */1 :
                var match$5 = dragInfo.windowPosition;
                var scriptPosition = variabletarget.scriptPosition;
                var chainFragmentsDoc$1 = Belt_Array.keepMap(state.chain.blocks, (function (block) {
                          var match = block.kind;
                          if (match !== 3) {
                            return ;
                          } else {
                            return block.body;
                          }
                        })).join("\n\n");
                var parsedOperation$1 = Graphql.parse(sourceRequest.operation.body);
                var definition$1 = Belt_Array.getExn(parsedOperation$1.definitions, 0);
                var onClose$2 = function (param) {
                  return Curry._1(setState, (function (oldState) {
                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                newrecord.connectionDrag = /* Empty */0;
                                return newrecord;
                              }));
                };
                tmp$3 = React.createElement(ChainEditor$PopupPicker, {
                      top: match$5[1],
                      left: match$5[0],
                      children: React.createElement(Inspector.GraphQLPreview.make, {
                            requestId: sourceRequest.id,
                            schema: schema,
                            definition: definition$1,
                            fragmentDefinitions: GraphQLJs.Mock.gatherFragmentDefinitions({
                                  operationDoc: chainFragmentsDoc$1
                                }),
                            targetGqlType: "[String]",
                            onCopy: (function (payload) {
                                var dataPath = Belt_Array.concat(["payload"], payload.path);
                                var re = new RegExp("\\[.+\\]", "g");
                                var len = dataPath.length;
                                var tmp;
                                if (len >= 3) {
                                  var parent = Caml_array.get(dataPath, dataPath.length - 2 | 0);
                                  var field = Utils.$$String.capitalizeFirstLetter(Caml_array.get(dataPath, dataPath.length - 1 | 0));
                                  tmp = parent + field;
                                } else {
                                  switch (len) {
                                    case 0 :
                                        tmp = "unknown";
                                        break;
                                    case 1 :
                                        tmp = dataPath[0];
                                        break;
                                    case 2 :
                                        tmp = dataPath[1];
                                        break;
                                    
                                  }
                                }
                                var binding = tmp.replace(re, "");
                                return Curry._1(setState, (function (oldState) {
                                              var parsed;
                                              try {
                                                parsed = Caml_option.some(Typescript.createSourceFile("main.ts", oldState.chain.script, 99, true));
                                              }
                                              catch (exn){
                                                parsed = undefined;
                                              }
                                              var lineNumber = Belt_Option.map(parsed, (function (parsed) {
                                                      try {
                                                        var position = parsed.getPositionOfLineAndCharacter(scriptPosition.lineNumber - 1 | 0, scriptPosition.column - 1 | 0);
                                                        var parsedPosition = Belt_Option.getExn(TypeScript.findPositionOfFirstLineOfContainingFunctionForPosition(parsed, position));
                                                        var lineAndCharacter = parsed.getLineAndCharacterOfPosition(parsedPosition);
                                                        return lineAndCharacter.line + 1 | 0;
                                                      }
                                                      catch (raw_e){
                                                        var e = Caml_js_exceptions.internalToOCamlException(raw_e);
                                                        console.warn("Exn trying to find smart position", e);
                                                        return scriptPosition.lineNumber - 1 | 0;
                                                      }
                                                    }));
                                              var assignmentExpressionRange = Belt_Option.flatMap(parsed, (function (parsed) {
                                                      var position = parsed.getPositionOfLineAndCharacter(scriptPosition.lineNumber - 1 | 0, scriptPosition.column - 1 | 0);
                                                      return TypeScript.findContainingDeclaration(parsed, position);
                                                    }));
                                              var newScript;
                                              if (assignmentExpressionRange !== undefined) {
                                                var newBinding = assignmentExpressionRange.name + " = " + dataPath.join("?.");
                                                newScript = Utils.$$String.replaceRange(oldState.chain.script, assignmentExpressionRange.start + 1 | 0, assignmentExpressionRange.end, newBinding);
                                              } else if (lineNumber !== undefined) {
                                                var newBinding$1 = "\tlet " + binding + " = " + dataPath.join("?.");
                                                var temp = oldState.chain.script.split("\n");
                                                temp.splice(lineNumber, 0, newBinding$1);
                                                newScript = temp.join("\n");
                                              } else {
                                                newScript = oldState.chain.script;
                                              }
                                              var init = oldState.chain;
                                              var newChain_name = init.name;
                                              var newChain_description = init.description;
                                              var newChain_id = init.id;
                                              var newChain_scriptDependencies = init.scriptDependencies;
                                              var newChain_requests = init.requests;
                                              var newChain_blocks = init.blocks;
                                              var newChain_accessToken = init.accessToken;
                                              var newChain_traceRetentionPolicy = init.traceRetentionPolicy;
                                              var newChain_yjsScript = init.yjsScript;
                                              var newChain = {
                                                name: newChain_name,
                                                description: newChain_description,
                                                id: newChain_id,
                                                script: newScript,
                                                scriptDependencies: newChain_scriptDependencies,
                                                requests: newChain_requests,
                                                blocks: newChain_blocks,
                                                accessToken: newChain_accessToken,
                                                traceRetentionPolicy: newChain_traceRetentionPolicy,
                                                yjsScript: newChain_yjsScript
                                              };
                                              var newrecord = Caml_obj.caml_obj_dup(oldState);
                                              newrecord.connectionDrag = /* Empty */0;
                                              newrecord.chain = newChain;
                                              return newrecord;
                                            }));
                              }),
                            onClose: (function (param) {
                                return Curry._1(setState, (function (oldState) {
                                              var newrecord = Caml_obj.caml_obj_dup(oldState);
                                              newrecord.connectionDrag = /* Empty */0;
                                              return newrecord;
                                            }));
                              }),
                            definitionResultData: definitionResultData
                          }),
                      onClose: onClose$2
                    });
                break;
            case /* Input */2 :
                var match$6 = dragInfo.windowPosition;
                var inputDom = variabletarget.inputDom;
                var chainFragmentsDoc$2 = Belt_Array.keepMap(state.chain.blocks, (function (block) {
                          var match = block.kind;
                          if (match !== 3) {
                            return ;
                          } else {
                            return block.body;
                          }
                        })).join("\n\n");
                var parsedOperation$2 = Graphql.parse(sourceRequest.operation.body);
                var definition$2 = Belt_Array.getExn(parsedOperation$2.definitions, 0);
                var onClose$3 = function (param) {
                  return Curry._1(setState, (function (oldState) {
                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                newrecord.connectionDrag = /* Empty */0;
                                return newrecord;
                              }));
                };
                tmp$3 = React.createElement(ChainEditor$PopupPicker, {
                      top: match$6[1],
                      left: match$6[0],
                      children: React.createElement(Inspector.GraphQLPreview.make, {
                            requestId: sourceRequest.id,
                            schema: schema,
                            definition: definition$2,
                            fragmentDefinitions: GraphQLJs.Mock.gatherFragmentDefinitions({
                                  operationDoc: chainFragmentsDoc$2
                                }),
                            targetGqlType: "[String]",
                            onCopy: (function (payload) {
                                try {
                                  Inspector.forceablySetInputValue(inputDom, payload.displayedData);
                                }
                                catch (exn){
                                  
                                }
                                return Curry._1(setState, (function (oldState) {
                                              var newrecord = Caml_obj.caml_obj_dup(oldState);
                                              newrecord.connectionDrag = /* Empty */0;
                                              return newrecord;
                                            }));
                              }),
                            onClose: (function (param) {
                                return Curry._1(setState, (function (oldState) {
                                              var newrecord = Caml_obj.caml_obj_dup(oldState);
                                              newrecord.connectionDrag = /* Empty */0;
                                              return newrecord;
                                            }));
                              }),
                            definitionResultData: definitionResultData
                          }),
                      onClose: onClose$3
                    });
                break;
            
          }
          break;
      case /* CompletedWithTypeMismatch */4 :
          var path = dragInfo.path;
          var dataPath = dragInfo.dataPath;
          var match$7 = dragInfo.windowPosition;
          var targetVariableType$1 = dragInfo.targetVariableType;
          var sourceType = dragInfo.sourceType;
          var variableTarget = dragInfo.variableTarget;
          var sourceRequest$1 = dragInfo.sourceRequest;
          var onClick$1 = function (name) {
            return Curry._1(setState, (function (oldState) {
                          var targetVariableDependency = variableTarget.variableDependency;
                          var newRequests = Belt_Array.map(oldState.chain.requests, (function (request) {
                                  if (variableTarget.targetRequest.id !== request.id) {
                                    return request;
                                  }
                                  var varDeps = Belt_Array.map(request.variableDependencies, (function (varDep) {
                                          if (varDep.name === targetVariableDependency.name) {
                                            var dependency = {
                                              TAG: 0,
                                              _0: {
                                                functionFromScript: "TBD",
                                                maxRecur: undefined,
                                                ifMissing: "SKIP",
                                                ifList: "FIRST",
                                                fromRequestIds: request.dependencyRequestIds,
                                                name: targetVariableDependency.name
                                              },
                                              [Symbol.for("name")]: "ArgumentDependency"
                                            };
                                            return {
                                                    name: varDep.name,
                                                    dependency: dependency
                                                  };
                                          }
                                          var argDep = varDep.dependency;
                                          var dependency$1;
                                          switch (argDep.TAG | 0) {
                                            case /* ArgumentDependency */0 :
                                                var argDep$1 = argDep._0;
                                                var newArgDep_functionFromScript = argDep$1.functionFromScript;
                                                var newArgDep_maxRecur = argDep$1.maxRecur;
                                                var newArgDep_ifMissing = argDep$1.ifMissing;
                                                var newArgDep_ifList = argDep$1.ifList;
                                                var newArgDep_fromRequestIds = Utils.$$String.distinctStrings(Belt_Array.concat(argDep$1.fromRequestIds, [sourceRequest$1.id]));
                                                var newArgDep_name = argDep$1.name;
                                                var newArgDep = {
                                                  functionFromScript: newArgDep_functionFromScript,
                                                  maxRecur: newArgDep_maxRecur,
                                                  ifMissing: newArgDep_ifMissing,
                                                  ifList: newArgDep_ifList,
                                                  fromRequestIds: newArgDep_fromRequestIds,
                                                  name: newArgDep_name
                                                };
                                                dependency$1 = {
                                                  TAG: 0,
                                                  _0: newArgDep,
                                                  [Symbol.for("name")]: "ArgumentDependency"
                                                };
                                                break;
                                            case /* Direct */1 :
                                            case /* GraphQLProbe */2 :
                                                dependency$1 = argDep;
                                                break;
                                            
                                          }
                                          return {
                                                  name: varDep.name,
                                                  dependency: dependency$1
                                                };
                                        }));
                                  return {
                                          id: request.id,
                                          variableDependencies: varDeps,
                                          operation: request.operation,
                                          dependencyRequestIds: Utils.$$String.distinctStrings(Belt_Array.concat(request.dependencyRequestIds, [sourceRequest$1.id]))
                                        };
                                }));
                          var request = Belt_Array.getBy(newRequests, (function (request) {
                                  return variableTarget.targetRequest.id === request.id;
                                }));
                          var script = Belt_Option.mapWithDefault(request, oldState.chain.script, (function (request) {
                                  var returnProperties = Belt_Array.keepMap(request.variableDependencies, (function (varDep) {
                                          var match = varDep.dependency;
                                          switch (match.TAG | 0) {
                                            case /* ArgumentDependency */0 :
                                                return [
                                                        varDep.name,
                                                        varDep.name
                                                      ];
                                            case /* Direct */1 :
                                            case /* GraphQLProbe */2 :
                                                return ;
                                            
                                          }
                                        }));
                                  return Inspector.ensureRequestFunctionExists(undefined, returnProperties, oldState.chain.script, request, undefined);
                                }));
                          var parsed;
                          try {
                            parsed = Caml_option.some(Typescript.createSourceFile("main.ts", script, 99, true));
                          }
                          catch (exn){
                            parsed = undefined;
                          }
                          var lineNumbers = Belt_Option.flatMap(request, (function (request) {
                                  var names = Chain.requestScriptNames(request);
                                  return Belt_Option.flatMap(parsed, (function (parsed) {
                                                return Belt_Option.map(TypeScript.findFnPos(parsed, names.functionName), (function (param) {
                                                              var match = parsed.getLineAndCharacterOfPosition(param.start);
                                                              var line = match.line;
                                                              var firstStatementLine = Belt_Option.mapWithDefault(param.firstStatementStart, line, (function (firstStatementStart) {
                                                                      return parsed.getLineAndCharacterOfPosition(firstStatementStart).line;
                                                                    }));
                                                              return [
                                                                      line,
                                                                      firstStatementLine
                                                                    ];
                                                            }));
                                              }));
                                }));
                          var re = new RegExp("\\[.+\\]", "g");
                          var inputName = Caml_array.get(dataPath, dataPath.length - 1 | 0).replace(re, "");
                          var binding = targetVariableDependency.name;
                          var nullableTargetVariableType = Belt_Option.map(targetVariableType$1, (function (typ) {
                                  return namedGraphQLScalarTypeScriptType(typ.replace(new RegExp("!", "g"), ""));
                                }));
                          var nullablePrintedType = sourceType.replace(new RegExp("!", "g"), "");
                          var defaultCoercerName = nullablePrintedType + "To" + Utils.$$String.capitalizeFirstLetter(Belt_Option.getWithDefault(nullableTargetVariableType, "Unknown"));
                          var coercerName = Utils.$$String.safeCamelize(name !== undefined ? name : Belt_Option.getWithDefault(Caml_option.nullable_to_opt(prompt("Coercer function name: ", Utils.$$String.safeCamelize(defaultCoercerName))), defaultCoercerName));
                          var coercerExists;
                          var exit = 0;
                          if (name === "INTERNAL_PASSTHROUGH") {
                            coercerExists = true;
                          } else {
                            exit = 1;
                          }
                          if (exit === 1) {
                            coercerExists = Belt_Option.isSome(Belt_Option.flatMap(parsed, (function (parsed) {
                                        return TypeScript.findFnPos(parsed, coercerName);
                                      })));
                          }
                          var newScript = Belt_Option.map(lineNumbers, (function (param) {
                                  var newBinding;
                                  var exit = 0;
                                  if (name === "INTERNAL_PASSTHROUGH") {
                                    newBinding = "\tlet " + binding + " = " + dataPath.join("?.");
                                  } else {
                                    exit = 1;
                                  }
                                  if (exit === 1) {
                                    newBinding = "\tlet " + binding + " = " + coercerName + "(" + dataPath.join("?.") + ")";
                                  }
                                  var temp = script.split("\n");
                                  temp.splice(param[1] + 1 | 0, 0, newBinding);
                                  var inputType = Belt_Option.mapWithDefault(request, nullablePrintedType, (function (request) {
                                          var names = Chain.requestScriptNames(request);
                                          var typePath = Belt_Array.joinWith(path, "", (function (step) {
                                                  if (!step.endsWith("[0]")) {
                                                    return "[\"" + step + "\"]";
                                                  }
                                                  var step$1 = step.replace("[0]", "");
                                                  return "[\"" + step$1 + "\"][0]";
                                                }));
                                          return names.inputTypeName + typePath;
                                        }));
                                  var signatureReturnType = Belt_Option.mapWithDefault(nullableTargetVariableType, "", (function (t) {
                                          return ": " + t;
                                        }));
                                  var newFunctionDefinition = "function " + coercerName + "(" + inputName + " : " + inputType + ") " + signatureReturnType + " {\n  /* TODO: Convert " + inputName + " => " + binding + " */\n  return " + inputName + "\n}";
                                  if (coercerExists) {
                                    return temp.join("\n");
                                  } else {
                                    return temp.join("\n") + "\n\n" + newFunctionDefinition;
                                  }
                                }));
                          var parsed$1 = Belt_Option.flatMap(newScript, (function (newScript) {
                                  try {
                                    return Caml_option.some(Typescript.createSourceFile("main.ts", newScript, 99, true));
                                  }
                                  catch (exn){
                                    return ;
                                  }
                                }));
                          var functionObjectLiteralReturn = Belt_Option.flatMap(request, (function (request) {
                                  var names = Chain.requestScriptNames(request);
                                  return Belt_Option.flatMap(parsed$1, (function (parsed) {
                                                return TypeScript.findLastReturnObjectPos(parsed, names.functionName, binding);
                                              }));
                                }));
                          var shouldInsertPropertyInReturn = Belt_Option.mapWithDefault(functionObjectLiteralReturn, false, (function ($$return) {
                                  return Belt_Option.isNone($$return.property);
                                }));
                          var newScript$1 = Belt_Option.map(newScript, (function (newScript) {
                                  return Belt_Option.mapWithDefault(functionObjectLiteralReturn, newScript, (function (returnObjectPositions) {
                                                if (!shouldInsertPropertyInReturn) {
                                                  return newScript;
                                                }
                                                Debug.assignToWindowForDeveloperDebug("tNewScript", newScript);
                                                var head = newScript.slice(0, returnObjectPositions.objectPosition.start + 2 | 0);
                                                var tail = newScript.slice(returnObjectPositions.objectPosition.start + 2 | 0, newScript.length);
                                                return head + " " + binding + ": " + binding + "," + tail;
                                              }));
                                }));
                          var init = oldState.chain;
                          var newChain_name = init.name;
                          var newChain_description = init.description;
                          var newChain_id = init.id;
                          var newChain_script = Belt_Option.getWithDefault(newScript$1, script);
                          var newChain_scriptDependencies = init.scriptDependencies;
                          var newChain_blocks = init.blocks;
                          var newChain_accessToken = init.accessToken;
                          var newChain_traceRetentionPolicy = init.traceRetentionPolicy;
                          var newChain_yjsScript = init.yjsScript;
                          var newChain = {
                            name: newChain_name,
                            description: newChain_description,
                            id: newChain_id,
                            script: newChain_script,
                            scriptDependencies: newChain_scriptDependencies,
                            requests: newRequests,
                            blocks: newChain_blocks,
                            accessToken: newChain_accessToken,
                            traceRetentionPolicy: newChain_traceRetentionPolicy,
                            yjsScript: newChain_yjsScript
                          };
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.connectionDrag = /* Empty */0;
                          newrecord.chain = newChain;
                          return newrecord;
                        }));
          };
          var onClose$4 = function (param) {
            return Curry._1(setState, (function (oldState) {
                          var newrecord = Caml_obj.caml_obj_dup(oldState);
                          newrecord.connectionDrag = /* Empty */0;
                          return newrecord;
                        }));
          };
          tmp$3 = React.createElement(ChainEditor$PopupPicker, {
                top: match$7[1],
                left: match$7[0],
                children: null,
                onClose: onClose$4
              }, React.createElement("span", {
                    style: {
                      color: Comps.colors["gray-2"]
                    }
                  }, "Type mismatch, choose coercer: "), React.createElement("ul", undefined, React.createElement("li", {
                        key: "INTERNAL_PASSTHROUGH",
                        className: "cursor-pointer graphql-structure-preview-entry",
                        onClick: (function (param) {
                            return onClick$1("INTERNAL_PASSTHROUGH");
                          })
                      }, "Passthrough"), Belt_Array.map(dragInfo.potentialFunctionMatches, (function (fn) {
                          return React.createElement("li", {
                                      key: fn.name,
                                      className: "cursor-pointer graphql-structure-preview-entry",
                                      onClick: (function (param) {
                                          return onClick$1(fn.name);
                                        })
                                    }, fn.name);
                        })), React.createElement("li", {
                        key: "createNew",
                        className: "cursor-pointer graphql-structure-preview-entry",
                        onClick: (function (param) {
                            return onClick$1(undefined);
                          })
                      }, "Create new function")));
          break;
      
    }
  }
  var tmp$5;
  if (helpOpen) {
    var connectionsHelp = Belt_Array.keep(Help.videoTutorials, (function (video) {
            return video.category === /* Connections */0;
          }));
    tmp$5 = React.createElement(Comps.Modal.make, {
          children: React.createElement("div", {
                className: "w-full h-full m-2 bg-gray-900"
              }, React.createElement("h1", {
                    style: {
                      color: Comps.colors["gray-6"]
                    }
                  }, "Draw connections with drag and drop:"), React.createElement("ul", {
                    style: {
                      color: Comps.colors["gray-4"]
                    }
                  }, Belt_Array.map(connectionsHelp, (function (video) {
                          return React.createElement("li", {
                                      key: video.title
                                    }, video.oneLineDescription, React.createElement("a", {
                                          style: {
                                            color: Comps.colors["blue-1"]
                                          },
                                          href: video.link,
                                          target: "_blank"
                                        }, "[Tutorial video]"));
                        }))))
        });
  } else {
    tmp$5 = null;
  }
  return React.createElement("div", {
              style: {
                height: "calc(100vh - 56px)"
              }
            }, React.createElement(ChainEditor$RequestValueCacheProvider, {
                  value: definitionResultData,
                  children: React.createElement(ChainEditor$InspectedContextProvider, {
                        value: state.inspected,
                        children: React.createElement(AudioStreamContext.Provider.make, {
                              value: state.audioStream,
                              children: React.createElement(ConnectionContext.Provider.make, {
                                    value: state.connectionDrag,
                                    children: null
                                  }, React.createElement("div", {
                                        className: "flex flex-row flex-nowrap"
                                      }, state.blockSearchOpen ? React.createElement(ReactResizePanel, {
                                              direction: "e",
                                              style: {
                                                width: "400px"
                                              },
                                              handleClass: "ResizeHandleHorizontal",
                                              children: React.createElement("div", {
                                                    className: "w-full",
                                                    style: {
                                                      backgroundColor: Comps.colors["gray-9"],
                                                      height: "calc(100vh - 56px)"
                                                    }
                                                  }, blockSearch)
                                            }) : React.createElement("div", {
                                              className: "cursor-pointer",
                                              style: {
                                                color: "white",
                                                width: "25px"
                                              },
                                              onClick: (function (param) {
                                                  return Curry._1(setState, (function (oldState) {
                                                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                                                newrecord.blockSearchOpen = true;
                                                                return newrecord;
                                                              }));
                                                })
                                            }, "▹"), React.createElement("div", {
                                            className: "flex-1 overflow-x-hidden"
                                          }, React.createElement("div", {
                                                style: {
                                                  height: "calc(50vh - 28px)"
                                                },
                                                onDragEnter: (function ($$event) {
                                                    $$event.stopPropagation();
                                                    $$event.preventDefault();
                                                    var dataTransfer = $$event.dataTransfer;
                                                    dataTransfer.dropEffect = "copy";
                                                    
                                                  }),
                                                onDragOver: (function ($$event) {
                                                    $$event.stopPropagation();
                                                    $$event.preventDefault();
                                                    var dataTransfer = $$event.dataTransfer;
                                                    dataTransfer.dropEffect = "copy";
                                                    
                                                  }),
                                                onDrop: (function ($$event) {
                                                    $$event.stopPropagation();
                                                    var dataTransfer = $$event.dataTransfer;
                                                    dataTransfer.dropEffect = "copy";
                                                    var blockId = dataTransfer.getData("text");
                                                    return Belt_Option.forEach(Belt_Array.getBy(state.blocks, (function (block) {
                                                                      return block.id.toString() === blockId;
                                                                    })), addBlock);
                                                  })
                                              }, Belt_Option.mapWithDefault(state.diagram, null, (function (diagram) {
                                                      return React.createElement(ChainEditor$Diagram, {
                                                                  setState: setState,
                                                                  diagram: diagram,
                                                                  chain: state.chain,
                                                                  removeEdge: removeEdge,
                                                                  removeRequest: removeRequest,
                                                                  diagramFromChain: diagramFromChain$1,
                                                                  trace: state.trace
                                                                });
                                                    }))), React.createElement("div", {
                                                style: {
                                                  height: "calc(50vh - 67px)"
                                                }
                                              }, React.createElement("div", {
                                                    className: "",
                                                    onClick: (function (param) {
                                                        return Curry._1(setState, (function (oldState) {
                                                                      var newrecord = Caml_obj.caml_obj_dup(oldState);
                                                                      var init = oldState.scriptEditor;
                                                                      newrecord.scriptEditor = {
                                                                        isOpen: !oldState.scriptEditor.isOpen,
                                                                        editor: init.editor,
                                                                        monaco: init.monaco
                                                                      };
                                                                      return newrecord;
                                                                    }));
                                                      })
                                                  }, React.createElement(Comps.Header.make, {
                                                        style: {
                                                          backgroundColor: Comps.colors["gray-9"],
                                                          display: "flex",
                                                          marginRight: "0px",
                                                          marginLeft: "0px"
                                                        },
                                                        children: null
                                                      }, React.createElement("div", {
                                                            className: "flex-grow"
                                                          }, "Chain JavaScript"), React.createElement("div", undefined, React.createElement("button", {
                                                                title: "Format code",
                                                                onClick: (function (param) {
                                                                    return Belt_Option.forEach(state.scriptEditor.editor, (function (editor) {
                                                                                  var script = editor.getValue();
                                                                                  var newScript = Prettier.format(script, {
                                                                                        parser: "babel",
                                                                                        plugins: [ParserBabel],
                                                                                        singleQuote: true
                                                                                      });
                                                                                  return Curry._1(setState, (function (oldState) {
                                                                                                var newrecord = Caml_obj.caml_obj_dup(oldState);
                                                                                                var init = oldState.chain;
                                                                                                newrecord.chain = {
                                                                                                  name: init.name,
                                                                                                  description: init.description,
                                                                                                  id: init.id,
                                                                                                  script: newScript,
                                                                                                  scriptDependencies: init.scriptDependencies,
                                                                                                  requests: init.requests,
                                                                                                  blocks: init.blocks,
                                                                                                  accessToken: init.accessToken,
                                                                                                  traceRetentionPolicy: init.traceRetentionPolicy,
                                                                                                  yjsScript: init.yjsScript
                                                                                                };
                                                                                                return newrecord;
                                                                                              }));
                                                                                }));
                                                                  })
                                                              }, React.createElement(Icons.Prettier.Dark.make, {
                                                                    width: "16px",
                                                                    height: "16px"
                                                                  }))))), React.createElement(ScriptEditor.make, tmp))), React.createElement(ReactResizePanel, {
                                            direction: "w",
                                            style: {
                                              width: "400px"
                                            },
                                            handleClass: "ResizeHandleHorizontal",
                                            children: React.createElement("div", {
                                                  className: "w-full",
                                                  style: {
                                                    backgroundColor: Comps.colors["gray-9"],
                                                    height: "calc(100vh - 56px)"
                                                  }
                                                }, sidebar)
                                          })), tmp$2, tmp$3)
                            })
                      })
                }), tmp$5, React.createElement("audio", {
                  id: "test-audio-tag",
                  autoPlay: true
                }), React.createElement("video", {
                  id: "test-video-tag",
                  style: {
                    left: "0",
                    position: "absolute",
                    top: "0",
                    width: "64%",
                    zIndex: "99999"
                  }
                }));
}

var Main = {
  make: ChainEditor$Main
};

function ChainEditor(Props) {
  var schema = Props.schema;
  var initialChain = Props.initialChain;
  var config = Props.config;
  var onSaveChain = Props.onSaveChain;
  var onClose = Props.onClose;
  var onSaveAndClose = Props.onSaveAndClose;
  var trace = Props.trace;
  var helpOpen = Props.helpOpen;
  var oneGraphAuth = OneGraphAuth.create({
        appId: config.oneGraphAppId
      });
  return Belt_Option.getWithDefault(Belt_Option.map(oneGraphAuth, (function (oneGraphAuth) {
                    return React.createElement(ReactFlowRenderer.ReactFlowProvider, {
                                children: React.createElement(ChainEditor$Main, {
                                      schema: schema,
                                      initialChain: initialChain,
                                      config: config,
                                      oneGraphAuth: oneGraphAuth,
                                      onSaveChain: onSaveChain,
                                      onClose: onClose,
                                      onSaveAndClose: onSaveAndClose,
                                      trace: trace,
                                      helpOpen: helpOpen
                                    })
                              });
                  })), "Loading Chain Editor...");
}

var httpRequest = "\ntype OutgoingHttpResponse {\n  body: String\n  headers: [[String!]!]\n  status: Int!\n}";

var make$1 = ChainEditor;

export {
  httpRequest ,
  SimpleTooltip ,
  FragmentNodeComponent ,
  makeBlankBlock ,
  namedGraphQLScalarTypeScriptType ,
  compileChain ,
  InspectedContextProvider ,
  RequestValueCacheProvider ,
  NodeLabel ,
  OperationNodeComponent ,
  emptyGraphLevel ,
  diagramFromChain ,
  backgroundStyle ,
  ConnectorLine ,
  Diagram ,
  PopupPicker ,
  chainResultToRequestValueCache ,
  persistChain ,
  Main ,
  make$1 as make,
  
}
/* make Not a pure module */
