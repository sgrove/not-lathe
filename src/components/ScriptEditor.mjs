// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Yjs from "../bindings/Yjs.mjs";
import * as Chain from "../Chain.mjs";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Debug from "../Debug.mjs";
import * as React from "react";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as TypeScript from "../bindings/TypeScript.mjs";
import Typescript from "typescript";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as SharedRooms from "./SharedRooms.mjs";
import * as BsReactMonaco from "../bindings/BsReactMonaco.mjs";
import * as ConnectionContext from "./ConnectionContext.mjs";
import * as QuickJsEmscripten from "./QuickJsEmscripten.mjs";
import * as AudioStreamContext from "./AudioStreamContext.mjs";

function ScriptEditor(Props) {
  var schema = Props.schema;
  var chain = Props.chain;
  var onChange = Props.onChange;
  var className = Props.className;
  var onMount = Props.onMount;
  var onPotentialScriptSourceConnect = Props.onPotentialScriptSourceConnect;
  var onSaveChain = Props.onSaveChain;
  var insight = Props.insight;
  var match = React.useState(function () {
        return chain.script;
      });
  var setLocalContent = match[1];
  var localContent = match[0];
  var match$1 = React.useState(function () {
        return [];
      });
  var setHighlights = match$1[1];
  var match$2 = React.useState(function () {
        return [];
      });
  var setContentWidgets = match$2[1];
  var contentWidgets = match$2[0];
  var content = chain.script;
  var editor = React.useRef(undefined);
  var monaco = React.useRef(undefined);
  var match$3 = Chain.monacoTypelibForChain(schema, chain);
  var types = match$3.dDotTs;
  var connectionDrag = React.useContext(ConnectionContext.context);
  var connectionDragRef = React.useRef(connectionDrag);
  var audioStreamContext = React.useContext(AudioStreamContext.context);
  var match$4 = React.useState(function () {
        var resolver = {
          contents: undefined
        };
        var handler = function (resolve, param) {
          resolver.contents = resolve;
          
        };
        var promise = new Promise(handler);
        return [
                promise,
                resolver.contents
              ];
      });
  var match$5 = match$4[0];
  var audioStreamResolver = match$5[1];
  var audioStreamPromise = match$5[0];
  React.useEffect((function () {
          if (audioStreamContext) {
            var stream = audioStreamContext._0;
            Belt_Option.forEach(audioStreamResolver, (function (resolver) {
                    return resolver(stream);
                  }));
          }
          
        }), [audioStreamContext]);
  React.useEffect((function () {
          var match = editor.current;
          var match$1 = monaco.current;
          if (insight.TAG === /* Ok */0 && match !== undefined && match$1 !== undefined) {
            var monaco$1 = Caml_option.valFromOption(match$1);
            var editor$1 = Caml_option.valFromOption(match);
            var match$2 = insight._0;
            var store = match$2.store;
            var lines = content.split("\n");
            Debug.assignToWindowForDeveloperDebug("MyRecordStore", store);
            var records = store.getGroupedLineDecorations(match$2.latestRunId, "/index.js", 1000, undefined);
            var newContentWidgets = Belt_Array.map(records, (function (result) {
                    var adjustedLineNumber = result.lineNum - 1 | 0;
                    var other = Belt_Option.mapWithDefault(Belt_Array.get(lines, adjustedLineNumber), 0, (function (prim) {
                            return prim.length;
                          }));
                    var horizontalOffset = other !== 0 ? other + 2 | 0 : 0;
                    return BsReactMonaco.createWidget(monaco$1, result.lineNum, result.hasError, horizontalOffset, result.content);
                  }));
            Belt_Array.forEach(contentWidgets, (function (contentWidget) {
                    editor$1.removeContentWidget(contentWidget);
                    
                  }));
            Belt_Array.forEach(newContentWidgets, (function (contentWidget) {
                    editor$1.addContentWidget(contentWidget);
                    
                  }));
            Curry._1(setContentWidgets, (function (param) {
                    return newContentWidgets;
                  }));
          }
          
        }), [
        insight,
        content,
        editor.current,
        monaco.current
      ]);
  React.useEffect((function () {
          connectionDragRef.current = connectionDrag;
          var match = editor.current;
          var match$1 = monaco.current;
          if (match !== undefined) {
            var editor$1 = Caml_option.valFromOption(match);
            var exit = 0;
            if (match$1 !== undefined && !(typeof connectionDrag === "number" || connectionDrag.TAG !== /* StartedSource */0)) {
              var monaco$1 = Caml_option.valFromOption(match$1);
              var __x = TypeScript.VirtualFileSystem.makeWithFileSystem(function (fsMap) {
                    fsMap.set("main.ts", chain.script);
                    
                  });
              __x.then(function (param) {
                    var parsed = Curry._1(param[1].getSourceFile, "main.ts");
                    return Promise.resolve(Belt_Option.forEach(parsed, (function (parsed) {
                                      var variableDeclarations = TypeScript.findAllVariableDeclarationsInFunctions(parsed);
                                      var decorations = Belt_Array.map(variableDeclarations, (function (node) {
                                              var start = parsed.getLineAndCharacterOfPosition(node.pos);
                                              var end = parsed.getLineAndCharacterOfPosition(node.end);
                                              return {
                                                      range: BsReactMonaco.makeRange(monaco$1, start.line + 1 | 0, start.character + 1 | 0, end.line + 1 | 0, end.character + 1 | 0),
                                                      options: {
                                                        className: "script-drop drag-target",
                                                        inlineClassName: "script-drop drag-target"
                                                      }
                                                    };
                                            }));
                                      Debug.assignToWindowForDeveloperDebug("OtherEditor", editor$1);
                                      Debug.assignToWindowForDeveloperDebug("OtherMonaco", monaco$1);
                                      Debug.assignToWindowForDeveloperDebug("OtherDecorations", decorations);
                                      var deltas = editor$1.deltaDecorations([], decorations);
                                      return Curry._1(setHighlights, (function (_oldHighlights) {
                                                    return deltas;
                                                  }));
                                    })));
                  });
            } else {
              exit = 1;
            }
            if (exit === 1) {
              Curry._1(setHighlights, (function (oldHighlights) {
                      editor$1.deltaDecorations(oldHighlights, []);
                      return [];
                    }));
            }
            
          }
          
        }), [ConnectionContext.toSimpleString(connectionDrag)]);
  React.useEffect((function () {
          if (content === localContent) {
            
          } else {
            Belt_Option.forEach(editor.current, (function (editor) {
                    var position = editor.getPosition();
                    var model = editor.getModel("file:///main.tsx");
                    var fullRange = model.getFullModelRange();
                    var edit = {
                      range: fullRange,
                      text: content
                    };
                    editor.executeEdits("externalContentChange", [edit]);
                    editor.setPosition(position);
                    
                  }));
          }
          
        }), [content]);
  React.useEffect((function () {
          Belt_Option.forEach(monaco.current, (function (monaco) {
                  var match = Chain.monacoTypelibForChain(schema, chain);
                  var importLine = match.importLine;
                  BsReactMonaco.TypeScript.addLib(monaco, match.dDotTs, content);
                  var hasImport = Belt_Option.isSome(Caml_option.null_to_opt(chain.script.match(new RegExp("import[\\s\\S.]+from[\\s\\S]+'oneGraphStudio';"))));
                  var newScript = hasImport ? chain.script.replace(new RegExp("import[\\s\\S.]+from[\\s\\S]+'oneGraphStudio';"), importLine) : importLine + "\n\n" + chain.script;
                  return Curry._1(onChange, newScript.trim());
                }));
          
        }), [types]);
  React.useEffect((function () {
          Belt_Option.forEach(monaco.current, (function (monaco) {
                  return Belt_Option.forEach(editor.current, (function (editor) {
                                var keyCode = BsReactMonaco.Key.combine([
                                      monaco.KeyMod.CtrlCmd,
                                      monaco.KeyCode.KEY_S
                                    ]);
                                editor.addCommand(keyCode, (function (param) {
                                        return Curry._1(onSaveChain, chain);
                                      }));
                                
                              }));
                }));
          
        }), [
        editor.current,
        monaco.current,
        chain
      ]);
  var filename = "file:///main.tsx";
  var tmp = {
    height: "100%",
    defaultValue: content,
    language: "typescript",
    theme: "vs-dark",
    options: {
      minimap: {
        enabled: false
      },
      contextmenu: false,
      contextMenu: false
    },
    onChange: (function (newScript, param) {
        Curry._1(setLocalContent, (function (param) {
                return newScript;
              }));
        return Curry._1(onChange, newScript);
      }),
    onMount: (function (editorHandle, monacoInstance) {
        Debug.assignToWindowForDeveloperDebug("myEditor", editorHandle);
        Debug.assignToWindowForDeveloperDebug("myMonaco", monacoInstance);
        Debug.assignToWindowForDeveloperDebug("myQuickJSGlobalTest2", QuickJsEmscripten.main);
        Debug.assignToWindowForDeveloperDebug("ts", Typescript);
        editorHandle.onMouseUp(function (mouseEvent) {
              Debug.assignToWindowForDeveloperDebug("editorMouseEvent", mouseEvent);
              var match = connectionDragRef.current;
              if (typeof match === "number") {
                return ;
              }
              if (match.TAG !== /* StartedSource */0) {
                return ;
              }
              var position = mouseEvent.target.position;
              var lineNumber = position.lineNumber;
              var column = position.column;
              var $$event = mouseEvent.event;
              var mousePositionX = $$event.posx;
              var mousePositionY = $$event.posy;
              var mousePosition = [
                mousePositionX,
                mousePositionY
              ];
              return Curry._4(onPotentialScriptSourceConnect, match.sourceRequest, match.sourceDom, {
                          lineNumber: lineNumber,
                          column: column
                        }, mousePosition);
            });
        BsReactMonaco.TypeScript.addLib(monacoInstance, types, content);
        BsReactMonaco.registerPrettier(monacoInstance);
        var modelOptions = {
          tabSize: 2
        };
        editor.current = Caml_option.some(editorHandle);
        monaco.current = Caml_option.some(monacoInstance);
        var model = editorHandle.getModel(filename);
        model.updateOptions(modelOptions);
        var sharedRoom = SharedRooms.idempotentCreate(chain.name, chain.yjsScript, audioStreamPromise);
        var text = sharedRoom.document.getText("monaco");
        var observer = function (textEvent, transaction) {
          console.log("Observed change in text: ", text, textEvent, transaction);
          text.unobserve(observer);
          
        };
        text.observe(observer);
        var awareness = sharedRoom.provider.awareness;
        var editors = Yjs.makeSet([editorHandle]);
        var shouldConnect = sharedRoom.provider.shouldConnect;
        Debug.assignToWindowForDeveloperDebug("sharedRoom", sharedRoom);
        console.log("Should connect to ", chain.name, shouldConnect);
        if (shouldConnect) {
          sharedRoom.provider.connect();
          sharedRoom.document.once("update", (function (update, origin, doc) {
                  console.log("Doc update after connect: ", update, origin, doc);
                  
                }));
        }
        Yjs.Monaco.createBinding(content, text, model, editors, awareness);
        return Curry._2(onMount, editorHandle, monacoInstance);
      }),
    path: filename
  };
  if (className !== undefined) {
    tmp.className = className;
  }
  return React.createElement("div", {
              style: {
                height: "calc(100vh - 40px - 384px - 56px)"
              }
            }, React.createElement(BsReactMonaco.Editor.make, tmp));
}

var make = ScriptEditor;

export {
  make ,
  
}
/* Yjs Not a pure module */
