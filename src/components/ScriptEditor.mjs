// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Yjs from "../bindings/Yjs.mjs";
import * as Yjs$1 from "yjs";
import * as Babel from "../bindings/Babel.mjs";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Debug from "../Debug.mjs";
import * as React from "react";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Compiler from "../lib/Compiler.mjs";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as TypeScript from "../bindings/TypeScript.mjs";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as BsReactMonaco from "../bindings/BsReactMonaco.mjs";
import * as RelayRuntime from "relay-runtime";
import * as ConnectionContext from "./ConnectionContext.mjs";
import * as Js_null_undefined from "rescript/lib/es6/js_null_undefined.js";
import * as Hooks from "react-relay/hooks";
import * as CollaborationContext from "./CollaborationContext.mjs";
import * as RescriptRelay_Internal from "rescript-relay/src/RescriptRelay_Internal.mjs";
import * as ScriptEditor_source_graphql from "../__generated__/ScriptEditor_source_graphql.mjs";
import * as ScriptEditor_OneGraphMutation_graphql from "../__generated__/ScriptEditor_OneGraphMutation_graphql.mjs";

function use(fRef) {
  var data = Hooks.useFragment(ScriptEditor_source_graphql.node, fRef);
  return RescriptRelay_Internal.internal_useConvertedValue(ScriptEditor_source_graphql.Internal.convertFragment, data);
}

function useOpt(opt_fRef) {
  var fr = opt_fRef !== undefined ? Caml_option.some(Caml_option.valFromOption(opt_fRef)) : undefined;
  var nullableFragmentData = Hooks.useFragment(ScriptEditor_source_graphql.node, fr !== undefined ? Js_null_undefined.fromOption(Caml_option.some(Caml_option.valFromOption(fr))) : null);
  var data = (nullableFragmentData == null) ? undefined : Caml_option.some(nullableFragmentData);
  return RescriptRelay_Internal.internal_useConvertedValue((function (rawFragment) {
                if (rawFragment !== undefined) {
                  return ScriptEditor_source_graphql.Internal.convertFragment(rawFragment);
                }
                
              }), data);
}

var ScriptEditorFragment = {
  Types: undefined,
  use: use,
  useOpt: useOpt
};

function commitMutation(environment, variables, optimisticUpdater, optimisticResponse, updater, onCompleted, onError, uploadables, param) {
  return RelayRuntime.commitMutation(environment, {
              mutation: ScriptEditor_OneGraphMutation_graphql.node,
              variables: ScriptEditor_OneGraphMutation_graphql.Internal.convertVariables(variables),
              onCompleted: (function (res, err) {
                  if (onCompleted !== undefined) {
                    return Curry._2(onCompleted, ScriptEditor_OneGraphMutation_graphql.Internal.convertResponse(res), (err == null) ? undefined : Caml_option.some(err));
                  }
                  
                }),
              onError: (function (err) {
                  if (onError !== undefined) {
                    return Curry._1(onError, (err == null) ? undefined : Caml_option.some(err));
                  }
                  
                }),
              optimisticResponse: optimisticResponse !== undefined ? ScriptEditor_OneGraphMutation_graphql.Internal.convertWrapRawResponse(optimisticResponse) : undefined,
              optimisticUpdater: optimisticUpdater,
              updater: updater !== undefined ? (function (store, r) {
                    return Curry._2(updater, store, ScriptEditor_OneGraphMutation_graphql.Internal.convertResponse(r));
                  }) : undefined,
              uploadables: uploadables
            });
}

function use$1(param) {
  var match = Hooks.useMutation(ScriptEditor_OneGraphMutation_graphql.node);
  var mutate = match[0];
  return [
          React.useMemo((function () {
                  return function (param, param$1, param$2, param$3, param$4, param$5, param$6, param$7, param$8) {
                    return Curry._1(mutate, {
                                onError: param,
                                onCompleted: param$1 !== undefined ? (function (r, errors) {
                                      return Curry._2(param$1, ScriptEditor_OneGraphMutation_graphql.Internal.convertResponse(r), (errors == null) ? undefined : Caml_option.some(errors));
                                    }) : undefined,
                                onUnsubscribe: param$2,
                                optimisticResponse: param$3 !== undefined ? ScriptEditor_OneGraphMutation_graphql.Internal.convertWrapRawResponse(param$3) : undefined,
                                optimisticUpdater: param$4,
                                updater: param$5 !== undefined ? (function (store, r) {
                                      return Curry._2(param$5, store, ScriptEditor_OneGraphMutation_graphql.Internal.convertResponse(r));
                                    }) : undefined,
                                variables: ScriptEditor_OneGraphMutation_graphql.Internal.convertVariables(param$6),
                                uploadables: param$7
                              });
                  };
                }), [mutate]),
          match[1]
        ];
}

var UpdateScriptMutation_make_oneGraphUpdateChainScriptSourceArg = ScriptEditor_OneGraphMutation_graphql.Utils.make_oneGraphUpdateChainScriptSourceArg;

var UpdateScriptMutation_make_oneGraphUpdateChainScriptInput = ScriptEditor_OneGraphMutation_graphql.Utils.make_oneGraphUpdateChainScriptInput;

var UpdateScriptMutation_makeVariables = ScriptEditor_OneGraphMutation_graphql.Utils.makeVariables;

var UpdateScriptMutation_make_response_oneGraph_updateChainScript_script = ScriptEditor_OneGraphMutation_graphql.Utils.make_response_oneGraph_updateChainScript_script;

var UpdateScriptMutation_make_response_oneGraph_updateChainScript = ScriptEditor_OneGraphMutation_graphql.Utils.make_response_oneGraph_updateChainScript;

var UpdateScriptMutation_make_response_oneGraph = ScriptEditor_OneGraphMutation_graphql.Utils.make_response_oneGraph;

var UpdateScriptMutation_makeOptimisticResponse = ScriptEditor_OneGraphMutation_graphql.Utils.makeOptimisticResponse;

var UpdateScriptMutation = {
  make_oneGraphUpdateChainScriptSourceArg: UpdateScriptMutation_make_oneGraphUpdateChainScriptSourceArg,
  make_oneGraphUpdateChainScriptInput: UpdateScriptMutation_make_oneGraphUpdateChainScriptInput,
  makeVariables: UpdateScriptMutation_makeVariables,
  make_response_oneGraph_updateChainScript_script: UpdateScriptMutation_make_response_oneGraph_updateChainScript_script,
  make_response_oneGraph_updateChainScript: UpdateScriptMutation_make_response_oneGraph_updateChainScript,
  make_response_oneGraph: UpdateScriptMutation_make_response_oneGraph,
  makeOptimisticResponse: UpdateScriptMutation_makeOptimisticResponse,
  Types: undefined,
  commitMutation: commitMutation,
  use: use$1
};

function filenameWithExtension(source) {
  var future_tag = source.language;
  if (future_tag !== "TYPESCRIPT") {
    console.warn("Unrecognized language, defaulting to .js file: ", future_tag);
  }
  return source.filename;
}

function ScriptEditor(Props) {
  var script = Props.script;
  var className = Props.className;
  var onMount = Props.onMount;
  var source = use(script);
  var match = use$1(undefined);
  var persistScript = match[0];
  var match$1 = React.useState(function () {
        return Belt_Option.getWithDefault(source.textualSource, "");
      });
  var setLocalContent = match$1[1];
  var match$2 = React.useState(function () {
        return {};
      });
  var setModels = match$2[1];
  var models = match$2[0];
  var collaboration = React.useContext(CollaborationContext.context);
  var match$3 = React.useState(function () {
        return [];
      });
  var setContentWidgets = match$3[1];
  var contentWidgets = match$3[0];
  var ydocument = React.useRef(undefined);
  var editor = React.useRef(undefined);
  var monaco = React.useRef(undefined);
  var filename = "file://" + filenameWithExtension(source);
  React.useEffect((function () {
          return (function (param) {
                    return Belt_Array.forEach(Js_dict.values(models), (function (model) {
                                  model.dispose();
                                  
                                }));
                  });
        }), []);
  var match$4 = React.useState(function () {
        
      });
  var setYjsEditor = match$4[1];
  var yjsEditor = match$4[0];
  React.useEffect((function () {
          var editor$1 = editor.current;
          if (editor$1 !== undefined) {
            var editors = Yjs.makeSet([Caml_option.valFromOption(editor$1)]);
            Curry._1(setYjsEditor, (function (param) {
                    return Caml_option.some(editors);
                  }));
          }
          
        }), [editor.current]);
  var hyperEval = function (script) {
    var runId = Babel.insight.contents.latestRunId + 1 | 0;
    var init = Babel.insight.contents;
    Babel.insight.contents = {
      store: init.store,
      latestRunId: runId,
      previousRunId: init.previousRunId
    };
    var transpiled = Compiler.babelTranspile(script, "/" + filenameWithExtension(source), runId);
    Curry._1(setLocalContent, (function (param) {
            return script;
          }));
    if (transpiled.TAG === /* Ok */0) {
      var transpiled$1 = transpiled._0;
      var fullTransformed_code = transpiled$1.code + "\n\n// TODO: Add invocations here";
      var fullTransformed_map = transpiled$1.map;
      var fullTransformed_ast = transpiled$1.ast;
      var fullTransformed = {
        code: fullTransformed_code,
        map: fullTransformed_map,
        ast: fullTransformed_ast
      };
      console.log("Hypereval: ", fullTransformed);
      return Compiler.evalBabelInQuick(fullTransformed, Babel.insight.contents, (function (results, store) {
                    var init = Babel.insight.contents;
                    Babel.insight.contents = {
                      store: store,
                      latestRunId: init.latestRunId,
                      previousRunId: runId - 1 | 0
                    };
                    console.log("Hypereval success: ", results, store, Babel.insight);
                    
                  }), (function (err) {
                    console.warn("Error hyperevaling: ", err);
                    
                  }));
    }
    console.warn("Error transpiling: ", transpiled._0);
    
  };
  React.useEffect((function () {
          console.log("Setting up observer for ydocument", ydocument.current);
          var unsub = {
            contents: undefined
          };
          Belt_Option.forEach(ydocument.current, (function ($$document) {
                  var text = $$document.getText("monaco");
                  var observer = function (_event, _origin) {
                    console.log("Detected change in document: ", source.filename);
                    return hyperEval(text.toString());
                  };
                  text.observe(observer);
                  unsub.contents = (function (param) {
                      console.log("Unsubscribing from observer to ydoc", ydocument);
                      text.unobserve(observer);
                      
                    });
                  
                }));
          return unsub.contents;
        }), [
        ydocument.current,
        source.id
      ]);
  React.useEffect((function () {
          var match = monaco.current;
          var match$1 = editor.current;
          var match$2 = source.concurrentSource;
          var match$3 = source.textualSource;
          var exit = 0;
          if (match !== undefined && match$1 !== undefined && match$2 !== undefined && match$3 !== undefined) {
            var collaborationContext = Curry._2(collaboration.getSharedChannel, source.id, match$2);
            if (collaborationContext !== undefined) {
              var text = collaborationContext.document.getText("monaco");
              ydocument.current = Caml_option.some(collaborationContext.document);
              var model = Js_dict.get(models, source.id);
              var existingModel;
              if (model !== undefined) {
                existingModel = Caml_option.valFromOption(model);
              } else {
                console.log("Create model: ", filename, text.toString());
                var model$1 = Caml_option.valFromOption(match).editor.createModel(match$3, "typescript", filename);
                Curry._1(setModels, (function (oldModels) {
                        oldModels[source.id] = model$1;
                        return oldModels;
                      }));
                console.log("Setting model bindings: ", yjsEditor, text.toString());
                Belt_Option.map(yjsEditor, (function (yjsEditor) {
                        return Yjs.Monaco.createBinding(text, model$1, yjsEditor, collaborationContext.provider.awareness);
                      }));
                existingModel = model$1;
              }
              Debug.assignToWindowForDeveloperDebug("allModels", models);
              Caml_option.valFromOption(match$1).setModel(existingModel);
            } else {
              console.log("Unable to get shared room for source.id: " + source.id);
            }
          } else {
            exit = 1;
          }
          if (exit === 1) {
            console.log("Delaying monaco binding... ", [
                  match,
                  match$1,
                  match$2,
                  match$3
                ]);
          }
          
        }), [
        monaco.current,
        editor.current,
        source.id
      ]);
  var match$5 = React.useState(function () {
        return [];
      });
  var setHighlights = match$5[1];
  var connectionDrag = React.useContext(ConnectionContext.context);
  var connectionDragRef = React.useRef(connectionDrag.value);
  React.useEffect((function () {
          var match = editor.current;
          var match$1 = monaco.current;
          var exit = 0;
          if (match !== undefined && match$1 !== undefined) {
            var monaco$1 = Caml_option.valFromOption(match$1);
            var editor$1 = Caml_option.valFromOption(match);
            var lines = editor$1.getValue().split("\n");
            Debug.assignToWindowForDeveloperDebug("MyRecordStore", Babel.insight.contents.store);
            var filePath = filenameWithExtension(source);
            var records = Babel.insight.contents.store.getGroupedLineDecorations(Babel.insight.contents.latestRunId, filePath, 1000, undefined);
            var newContentWidgets = Belt_Array.map(records, (function (result) {
                    var adjustedLineNumber = result.lineNum - 1 | 0;
                    var other = Belt_Option.mapWithDefault(Belt_Array.get(lines, adjustedLineNumber), 0, (function (prim) {
                            return prim.length;
                          }));
                    var horizontalOffset = other !== 0 ? other + 2 | 0 : 0;
                    return BsReactMonaco.createWidget(monaco$1, result.lineNum, result.hasError, horizontalOffset, result.content);
                  }));
            Belt_Array.forEach(contentWidgets, (function (contentWidget) {
                    editor$1.removeContentWidget(contentWidget);
                    
                  }));
            Belt_Array.forEach(newContentWidgets, (function (contentWidget) {
                    editor$1.addContentWidget(contentWidget);
                    
                  }));
            console.log("Rendering insight widgets: ", newContentWidgets, Babel.insight.contents.store);
            Curry._1(setContentWidgets, (function (param) {
                    return newContentWidgets;
                  }));
          } else {
            exit = 1;
          }
          if (exit === 1) {
            console.log("Ignoring insight effect: ", Babel.insight, editor.current, monaco.current);
          }
          
        }), [
        match$1[0],
        editor.current,
        monaco.current
      ]);
  React.useEffect((function () {
          connectionDragRef.current = connectionDrag.value;
          var match = editor.current;
          var match$1 = monaco.current;
          var match$2 = connectionDrag.value;
          var match$3 = source.textualSource;
          if (match !== undefined) {
            var editor$1 = Caml_option.valFromOption(match);
            var exit = 0;
            if (match$1 !== undefined && !(typeof match$2 === "number" || !(match$2.TAG === /* StartedSource */0 && match$3 !== undefined))) {
              var monaco$1 = Caml_option.valFromOption(match$1);
              var __x = TypeScript.VirtualFileSystem.makeWithFileSystem(filenameWithExtension(source), (function (fsMap) {
                      fsMap.set("/index.ts", "import * as X from './VariableTest4.ts'\n// Go for it!\nconsole.log(true)");
                      fsMap.set(filenameWithExtension(source), match$3);
                      
                    }));
              __x.then(function (param) {
                    var program = param[1];
                    var parsed = Curry._1(program.getSourceFile, filenameWithExtension(source));
                    console.log("Parsed/program: ", parsed, program, param[3]);
                    return Promise.resolve(Belt_Option.forEach(parsed, (function (parsed) {
                                      var variableDeclarations = TypeScript.findAllVariableDeclarationsInFunctions(parsed);
                                      console.log("\tVarDecs: ", variableDeclarations);
                                      var decorations = Belt_Array.map(variableDeclarations, (function (node) {
                                              var start = parsed.getLineAndCharacterOfPosition(node.pos);
                                              var end = parsed.getLineAndCharacterOfPosition(node.end);
                                              return {
                                                      range: BsReactMonaco.makeRange(monaco$1, start.line + 1 | 0, start.character + 1 | 0, end.line + 1 | 0, end.character + 1 | 0),
                                                      options: {
                                                        className: "script-drop drag-target",
                                                        inlineClassName: "script-drop drag-target"
                                                      }
                                                    };
                                            }));
                                      Debug.assignToWindowForDeveloperDebug("OtherEditor", editor$1);
                                      Debug.assignToWindowForDeveloperDebug("OtherMonaco", monaco$1);
                                      Debug.assignToWindowForDeveloperDebug("OtherDecorations", decorations);
                                      var deltas = editor$1.deltaDecorations([], decorations);
                                      return Curry._1(setHighlights, (function (_oldHighlights) {
                                                    return deltas;
                                                  }));
                                    })));
                  });
            } else {
              exit = 1;
            }
            if (exit === 1) {
              Curry._1(setHighlights, (function (oldHighlights) {
                      editor$1.deltaDecorations(oldHighlights, []);
                      return [];
                    }));
            }
            
          }
          
        }), [ConnectionContext.toSimpleString(connectionDrag.value)]);
  React.useEffect((function () {
          Belt_Option.forEach(monaco.current, (function (monaco) {
                  return Belt_Option.forEach(editor.current, (function (editor) {
                                var keyCode = BsReactMonaco.Key.combine([
                                      monaco.KeyMod.CtrlCmd,
                                      monaco.KeyCode.KEY_S
                                    ]);
                                editor.addCommand(keyCode, (function (param) {
                                        return Belt_Option.forEach(ydocument.current, (function (ydocument) {
                                                      var onCompleted = function (param, param$1) {
                                                        console.log("Finished persisting document");
                                                        
                                                      };
                                                      var concurrentSource = CollaborationContext.encodeUint8Array(Yjs$1.encodeStateAsUpdate(ydocument));
                                                      var textualSource = ydocument.getText("monaco").toString();
                                                      Debug.assignToWindowForDeveloperDebug("ydoc", ydocument);
                                                      Curry.app(persistScript, [
                                                            undefined,
                                                            onCompleted,
                                                            undefined,
                                                            undefined,
                                                            undefined,
                                                            undefined,
                                                            {
                                                              input: {
                                                                source: {
                                                                  concurrentSource: concurrentSource,
                                                                  textualSource: textualSource
                                                                },
                                                                id: source.id
                                                              }
                                                            },
                                                            undefined,
                                                            undefined
                                                          ]);
                                                      
                                                    }));
                                      }));
                                
                              }));
                }));
          
        }), [
        editor.current,
        monaco.current,
        source.id
      ]);
  var css = Belt_Option.mapWithDefault(Curry._1(collaboration.getSharedChannelState, source.id), [], (function (param) {
            var entries = Array.from(param[1].entries());
            return Belt_Array.map(entries, (function (param) {
                          var clientId = param[0];
                          var color = param[1].color;
                          return "\n." + clientId + " {\n  backgroundColor: " + color + ";\n}\n\n.yRemoteSelection-" + clientId + " {\n  background-color: " + color + ";\n}\n\n.yRemoteSelectionHead-" + clientId + " {\n  position: absolute;\n  border-left: " + color + " solid 2px;\n  border-top: " + color + " solid 2px;\n  border-bottom: " + color + " solid 2px;\n  height: 100%;\n  box-sizing: border-box;\n}\n.yRemoteSelectionHead-" + clientId + "::after {\n  position: absolute;\n  content: ' ';\n  border: 3px solid " + color + ";\n  border-radius: 4px;\n  left: -4px;\n  top: -5px;\n}\n";
                        }));
          })).join("\n");
  var tmp = {
    height: "100%",
    language: "typescript",
    theme: "vs-dark",
    options: {
      minimap: {
        enabled: false
      },
      contextmenu: false,
      contextMenu: false
    },
    onChange: (function (newScript, param) {
        return hyperEval(newScript);
      }),
    onMount: (function (editorHandle, monacoInstance) {
        Debug.assignToWindowForDeveloperDebug("myEditor", editorHandle);
        Debug.assignToWindowForDeveloperDebug("myMonaco", monacoInstance);
        editorHandle.onMouseUp(function (mouseEvent) {
              var match = connectionDragRef.current;
              if (typeof match === "number") {
                return ;
              }
              if (match.TAG !== /* StartedSource */0) {
                return ;
              }
              var position = mouseEvent.target.position;
              var lineNumber = position.lineNumber;
              var column = position.column;
              var $$event = mouseEvent.event;
              var mousePositionX = $$event.posx;
              var mousePositionY = $$event.posy;
              var mousePosition = [
                mousePositionX,
                mousePositionY
              ];
              return Curry._5(connectionDrag.onPotentialScriptSourceConnect, source.id, match.sourceActionId, match.sourceDom, {
                          lineNumber: lineNumber,
                          column: column
                        }, mousePosition);
            });
        BsReactMonaco.registerPrettier(monacoInstance);
        var modelOptions = {
          tabSize: 2
        };
        editorHandle.getModel(filename).updateOptions(modelOptions);
        editor.current = Caml_option.some(editorHandle);
        monaco.current = Caml_option.some(monacoInstance);
        console.log("Editor/Monaco mount: ", editor, monaco, filename);
        return Curry._2(onMount, editorHandle, monacoInstance);
      }),
    path: "file:///tmp.txt"
  };
  if (className !== undefined) {
    tmp.className = className;
  }
  return React.createElement(React.Fragment, undefined, React.createElement("style", {
                  id: "collaboration-css",
                  dangerouslySetInnerHTML: {
                    __html: css
                  }
                }), React.createElement("div", {
                  style: {
                    height: "calc(100vh - 40px - 384px - 56px)"
                  }
                }, match[1] ? "Saving..." : null, React.createElement(BsReactMonaco.Editor.make, tmp)));
}

var make = ScriptEditor;

export {
  ScriptEditorFragment ,
  UpdateScriptMutation ,
  filenameWithExtension ,
  make ,
  
}
/* Yjs Not a pure module */
