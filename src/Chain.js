// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Card from "./Card.js";
import * as Uuid from "./bindings/Uuid.js";
import * as Uuid$1 from "uuid";
import * as Utils from "./Utils.js";
import * as $$String from "bs-platform/lib/es6/string.mjs";
import * as Graphql from "graphql";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.mjs";
import * as GraphQLJs from "./bindings/GraphQLJs.js";
import * as Belt_Array from "bs-platform/lib/es6/belt_Array.mjs";
import * as Caml_array from "bs-platform/lib/es6/caml_array.mjs";
import * as Belt_Option from "bs-platform/lib/es6/belt_Option.mjs";
import * as Caml_option from "bs-platform/lib/es6/caml_option.mjs";
import * as GraphQLUtils from "./bindings/GraphQLUtils.js";
import * as Belt_SetString from "bs-platform/lib/es6/belt_SetString.mjs";
import * as Belt_SortArray from "bs-platform/lib/es6/belt_SortArray.mjs";
import * as Caml_exceptions from "bs-platform/lib/es6/caml_exceptions.mjs";
import * as Caml_js_exceptions from "bs-platform/lib/es6/caml_js_exceptions.mjs";

function stringOfIfMissing(x) {
  if (x === "ALLOW") {
    return "ALLOW";
  } else if (x === "SKIP") {
    return "SKIP";
  } else {
    return "ERROR";
  }
}

function ifMissingOfString(s) {
  switch (s) {
    case "ALLOW" :
        return {
                TAG: 0,
                _0: "ALLOW",
                [Symbol.for("name")]: "Ok"
              };
    case "ERROR" :
        return {
                TAG: 0,
                _0: "ERROR",
                [Symbol.for("name")]: "Ok"
              };
    case "SKIP" :
        return {
                TAG: 0,
                _0: "SKIP",
                [Symbol.for("name")]: "Ok"
              };
    default:
      return {
              TAG: 1,
              _0: s,
              [Symbol.for("name")]: "Error"
            };
  }
}

function stringOfIfList(x) {
  if (x === "ALL") {
    return "ALL";
  } else if (x === "EACH") {
    return "EACH";
  } else if (x === "LAST") {
    return "LAST";
  } else {
    return "FIRST";
  }
}

function ifListOfString(s) {
  switch (s) {
    case "ALL" :
        return {
                TAG: 0,
                _0: "ALL",
                [Symbol.for("name")]: "Ok"
              };
    case "EACH" :
        return {
                TAG: 0,
                _0: "EACH",
                [Symbol.for("name")]: "Ok"
              };
    case "FIRST" :
        return {
                TAG: 0,
                _0: "FIRST",
                [Symbol.for("name")]: "Ok"
              };
    case "LAST" :
        return {
                TAG: 0,
                _0: "LAST",
                [Symbol.for("name")]: "Ok"
              };
    default:
      return {
              TAG: 1,
              _0: s,
              [Symbol.for("name")]: "Error"
            };
  }
}

var base = "mutation ExecuteChainMutation($chain: OneGraphQueryChainInput!) {\n  oneGraph {\n    executeChain(\n      input: $chain\n    ) {\n      results {\n        request {\n          id\n        }\n        result\n        argumentDependencies {\n          name\n          returnValues\n          logs {\n            level\n            body\n          }\n          error {\n            name\n            message\n            stackString\n          }\n        }\n      }\n    }\n  }\n}";

function makeChain(operations) {
  return operations + "\n\n" + base;
}

var addToDocMutation_id = Uuid.parseExn("319e8375-16f0-434b-8f9a-3a1d364fe5df");

var addToDocMutation_body = "mutation AddToDocMutation($sheetId: String!, $row: [String!]!) {\n  google {\n    sheets {\n      appendValues(\n        id: $sheetId\n        valueInputOption: \"USER_ENTERED\"\n        majorDimenson: \"ROWS\"\n        range: \"'Raw Data'!A1\"\n        values: [$row]\n      ) {\n        updates {\n          spreadsheetId\n          updatedRange\n          updatedCells\n          updatedData {\n            values\n          }\n        }\n      }\n    }\n  }\n}";

var addToDocMutation_contributedBy = "@sgrove";

var addToDocMutation_services = ["google"];

var addToDocMutation = {
  id: addToDocMutation_id,
  title: "AddToDocMutation",
  description: "Insert a row into a Google Docs spreadsheet",
  body: addToDocMutation_body,
  kind: /* Mutation */1,
  contributedBy: addToDocMutation_contributedBy,
  services: addToDocMutation_services
};

var slackSub_id = Uuid.parseExn("942ae063-f7b4-4747-bae0-be427a8802e7");

var slackSub_body = "subscription SlackReactionSubscription(\n  $webhookUrl: String!\n) {\n  slack(webhookUrl: $webhookUrl) {\n    reactionAddedEvent {\n      eventTime\n      event {\n        user {\n          id\n          name          \n        }        \n        eventTs\n        reaction\n        item {\n          channel {\n            name\n          }\n          message {\n            permaLink\n            user {\n              id\n              name              \n            }\n            text\n            ts\n          }\n        }        \n      }\n    }\n  }\n}";

var slackSub_contributedBy = "@sgrove";

var slackSub_services = ["slack"];

var slackSub = {
  id: slackSub_id,
  title: "SlackReactionSubscription",
  description: "Provide notifications when someone reacts with an emoji to a message on Slack",
  body: slackSub_body,
  kind: /* Subscription */2,
  contributedBy: slackSub_contributedBy,
  services: slackSub_services
};

var npmDownloadsLastMonth_id = Uuid.parseExn("084beb2a-aae1-4a59-a3e8-7beaa383bd1a");

var npmDownloadsLastMonth_body = "query NpmDownloadsLastMonth {\n  npm {\n    downloads {\n      lastMonth {\n        count\n        end\n        start\n        ... on NpmOverallDownloadPeriodData {\n          end\n          start\n        }\n        perDay {\n          count\n          day\n        }\n      }\n    }\n  }\n}";

var npmDownloadsLastMonth_contributedBy = "@sgrove";

var npmDownloadsLastMonth_services = ["npm"];

var npmDownloadsLastMonth = {
  id: npmDownloadsLastMonth_id,
  title: "NpmDownloadsLastMonth",
  description: "Find the total number of downloads from npm in the past 30 days",
  body: npmDownloadsLastMonth_body,
  kind: /* Query */0,
  contributedBy: npmDownloadsLastMonth_contributedBy,
  services: npmDownloadsLastMonth_services
};

var testMutation_id = Uuid.parseExn("1886ccd2-7c37-49de-901b-e196221a94a0");

var testMutation_body = "mutation TestMutation($query: String!,\n  $another: [OneGraphQueryChainInput!]\n  #, $temp: String, $age: Int!, $unlisted: Boolean!\n  ) {\n  testMutate(query: $query)\n}";

var testMutation_contributedBy = "@sgrove";

var testMutation_services = [];

var testMutation = {
  id: testMutation_id,
  title: "TestMutation",
  description: "Test mutation as a sanity test for tooling",
  body: testMutation_body,
  kind: /* Mutation */1,
  contributedBy: testMutation_contributedBy,
  services: testMutation_services
};

var req1_variableDependencies = [{
    name: "webhookUrl",
    dependency: {
      TAG: 1,
      _0: {
        name: "webhookUrl",
        value: {
          TAG: 1,
          _0: "$webhookUrl",
          [Symbol.for("name")]: "Variable"
        }
      },
      [Symbol.for("name")]: "Direct"
    }
  }];

var req1_dependencyRequestIds = [];

var req1 = {
  id: "SlackReactionSubscription",
  variableDependencies: req1_variableDependencies,
  operation: slackSub,
  dependencyRequestIds: req1_dependencyRequestIds
};

var req2_variableDependencies = [
  {
    name: "row",
    dependency: {
      TAG: 0,
      _0: {
        functionFromScript: "getRow",
        maxRecur: undefined,
        ifMissing: "SKIP",
        ifList: "ALL",
        fromRequestIds: ["SlackReactionSubscription"],
        name: "row"
      },
      [Symbol.for("name")]: "ArgumentDependency"
    }
  },
  {
    name: "sheetId",
    dependency: {
      TAG: 1,
      _0: {
        name: "sheetId",
        value: {
          TAG: 1,
          _0: "$sheetId",
          [Symbol.for("name")]: "Variable"
        }
      },
      [Symbol.for("name")]: "Direct"
    }
  }
];

var req2_dependencyRequestIds = [];

var req2 = {
  id: "AddToDocMutation",
  variableDependencies: req2_variableDependencies,
  operation: addToDocMutation,
  dependencyRequestIds: req2_dependencyRequestIds
};

var req3_variableDependencies = [];

var req3_dependencyRequestIds = [];

var req3 = {
  id: "NpmDownloadsLastMonth",
  variableDependencies: req3_variableDependencies,
  operation: npmDownloadsLastMonth,
  dependencyRequestIds: req3_dependencyRequestIds
};

var req4_variableDependencies = [{
    name: "query",
    dependency: {
      TAG: 0,
      _0: {
        functionFromScript: "getStatus",
        maxRecur: undefined,
        ifMissing: "ERROR",
        ifList: "FIRST",
        fromRequestIds: ["NpmDownloadsLastMonth"],
        name: "query"
      },
      [Symbol.for("name")]: "ArgumentDependency"
    }
  }];

var req4_dependencyRequestIds = [];

var req4 = {
  id: "TestMutation",
  variableDependencies: req4_variableDependencies,
  operation: testMutation,
  dependencyRequestIds: req4_dependencyRequestIds
};

var req5_variableDependencies = [{
    name: "login",
    dependency: {
      TAG: 1,
      _0: {
        name: "login",
        value: {
          TAG: 1,
          _0: "gitHubLogin",
          [Symbol.for("name")]: "Variable"
        }
      },
      [Symbol.for("name")]: "Direct"
    }
  }];

var req5_dependencyRequestIds = [];

var req5 = {
  id: "GitHubStatus",
  variableDependencies: req5_variableDependencies,
  operation: Card.gitHubStatus,
  dependencyRequestIds: req5_dependencyRequestIds
};

var req6_variableDependencies = [{
    name: "jsonBody",
    dependency: {
      TAG: 0,
      _0: {
        functionFromScript: "",
        maxRecur: undefined,
        ifMissing: "SKIP",
        ifList: "FIRST",
        fromRequestIds: ["GitHubStatus"],
        name: "jsonBody"
      },
      [Symbol.for("name")]: "ArgumentDependency"
    }
  }];

var req6_dependencyRequestIds = ["GitHubStatus"];

var req6 = {
  id: "SetSlackStatus",
  variableDependencies: req6_variableDependencies,
  operation: Card.setSlackStatus,
  dependencyRequestIds: req6_dependencyRequestIds
};

var chain2_scriptDependencies = [];

var chain2_requests = [
  req1,
  req2,
  req3,
  req4
];

var chain2_blocks = [
  addToDocMutation,
  slackSub
];

var chain2 = {
  name: "chain2",
  description: undefined,
  id: undefined,
  script: "export function getRow(result) {\n          const event = result.SlackReactionSubscription[0].data.slack.reactionAddedEvent.event;\n          const reaction = event.reaction;\n          if (reaction !== 'eyes' && reaction !== 'white_check_mark') {\n            return null;\n          }\n          return [\n            event.item.message.permaLink, // message_permalink\n            event.item.message.text || '', // message_text\n            `=DATEOFTIMESTAMP(${event.item.message.ts} * 1000)`, // message_ts\n            event.item.message.user.id || '', // message_user_id (we don't have this yet :/)\n            event.item.message.user.name || '', // message_user_name\n            reaction === 'eyes' ? `=DATEOFTIMESTAMP(${event.eventTs} * 1000)` : '', // eyes_reaction_ts\n            reaction === 'eyes' ? event.user.id : '', // eyes_reaction_user_id\n            reaction === 'eyes' ? event.user.name : '', // eyes_reaction_user_name\n            reaction === 'white_check_mark' ? `=DATEOFTIMESTAMP(${event.eventTs} * 1000)` : '', //completed_reaction_ts\n            reaction === 'white_check_mark' ? event.user.id : '', // completed_reaction_user_id\n            reaction === 'white_check_mark' ? event.user.name : '', // completed_reaction_user_name\n            event.item.channel.name // channel_name\n          ]\n        }",
  scriptDependencies: chain2_scriptDependencies,
  requests: chain2_requests,
  blocks: chain2_blocks
};

var _chain_script = "import {\n  GitHubStatusInput,\n  GitHubStatusVariables,\n  SetSlackStatusInput,\n  SetSlackStatusVariables,\n} from 'oneGraphStudio';\n\nexport function makeVariablesForSetSlackStatus(\n  payload: SetSlackStatusInput\n): SetSlackStatusVariables {\n  let status = payload.GitHubStatus?.data?.gitHub?.user?.status?.message;\n\n  if (!status) {\n    return null;\n  }\n\n  return {\n    jsonBody: {\n      profile: {\n        status_text: status,\n      },\n    },\n  };\n}";

var _chain_scriptDependencies = [];

var _chain_requests = [
  req5,
  req6
];

var _chain_blocks = [
  Card.gitHubStatus,
  Card.setSlackStatus
];

var _chain = {
  name: "main",
  description: undefined,
  id: undefined,
  script: _chain_script,
  scriptDependencies: _chain_scriptDependencies,
  requests: _chain_requests,
  blocks: _chain_blocks
};

function makeEmptyChain(name) {
  return {
          name: name,
          description: undefined,
          id: Caml_option.some(Uuid$1.v4()),
          script: "",
          scriptDependencies: [],
          requests: [],
          blocks: []
        };
}

var emptyChain_script = "";

var emptyChain_scriptDependencies = [];

var emptyChain_requests = [];

var emptyChain_blocks = [];

var emptyChain = {
  name: "new_chain",
  description: undefined,
  id: undefined,
  script: emptyChain_script,
  scriptDependencies: emptyChain_scriptDependencies,
  requests: emptyChain_requests,
  blocks: emptyChain_blocks
};

function compileAsObj(chain) {
  var operations = Belt_Array.joinWith(chain.blocks, "\n", (function (x) {
          return x.body;
        }));
  var makeRequest = function (request) {
    var variables = Belt_Array.keepMap(request.variableDependencies, (function (dep) {
            var variable = dep.dependency;
            switch (variable.TAG | 0) {
              case /* Direct */1 :
                  var variable$1 = variable._0;
                  var json = variable$1.value;
                  var tmp;
                  tmp = json._0;
                  return {
                          name: variable$1.name,
                          value: tmp
                        };
              case /* ArgumentDependency */0 :
              case /* GraphQLProbe */2 :
                  return ;
              
            }
          }));
    var argumentDependencies = Belt_Array.keepMap(request.variableDependencies, (function (dep) {
            var dep$1 = dep.dependency;
            switch (dep$1.TAG | 0) {
              case /* ArgumentDependency */0 :
                  var dep$2 = dep$1._0;
                  return {
                          name: dep$2.name,
                          ifList: dep$2.ifList,
                          ifMissing: dep$2.ifMissing,
                          fromRequestIds: dep$2.fromRequestIds,
                          maxRecur: dep$2.maxRecur,
                          functionFromScript: dep$2.functionFromScript
                        };
              case /* Direct */1 :
                  return ;
              case /* GraphQLProbe */2 :
                  var probe = dep$1._0;
                  return {
                          name: probe.name,
                          ifList: probe.ifList,
                          ifMissing: probe.ifMissing,
                          fromRequestIds: [probe.fromRequestId],
                          maxRecur: undefined,
                          functionFromScript: "TODO"
                        };
              
            }
          }));
    return {
            id: request.id,
            operationName: request.operation.title,
            variables: variables,
            argumentDependencies: argumentDependencies
          };
  };
  var requests = Belt_Array.map(chain.requests, makeRequest);
  var input = {
    requests: requests,
    script: chain.script
  };
  return {
          operationDoc: "\n" + operations + "\n\n" + base,
          variables: {
            chain: input
          }
        };
}

function requestScriptNames(request) {
  var title = Utils.$$String.capitalizeFirstLetter(request.operation.title);
  var functionName = "makeVariablesFor" + title;
  var returnTypeName = title + "Variables";
  var inputTypeName = title + "Input";
  return {
          functionName: functionName,
          returnTypeName: returnTypeName,
          inputTypeName: inputTypeName
        };
}

function callForVariable(request, variableName) {
  var requestScriptName = requestScriptNames(request).functionName;
  return "export function " + requestScriptName + "_" + variableName + " (payload) {\n  return " + requestScriptName + "(payload)?.[\"" + variableName + "\"]\n}";
}

function callForProbe(request, variableName, probe) {
  var requestScriptName = requestScriptNames(request).functionName;
  var other = probe.path;
  var path = other.length !== 0 ? other.join("?.") : "null";
  return "export function " + requestScriptName + "_" + variableName + " (payload) {\n  return " + path + "\n}";
}

function compileOperationDoc(schema, webhookUrl, chain) {
  var blockOperations = Belt_Array.joinWith(Belt_Array.map(chain.blocks, (function (block) {
              var match = block.kind;
              if (match !== 2) {
                return block;
              }
              var body = block.body;
              var parsed = Graphql.parse(body);
              var definition = parsed.definitions[0];
              var newDefinition = GraphQLJs.Mock.patchSubscriptionWebhookField({
                    schema: schema,
                    definition: definition,
                    webhookUrl: webhookUrl
                  });
              var newBody = Graphql.print(newDefinition);
              return {
                      id: block.id,
                      title: block.title,
                      description: block.description,
                      body: newBody,
                      kind: block.kind,
                      contributedBy: block.contributedBy,
                      services: block.services
                    };
            })), "\n", (function (x) {
          return x.body;
        }));
  var exposedVariables = Belt_Array.concatMany(Belt_Array.map(chain.requests, (function (request) {
              return Belt_Array.keepMap(request.variableDependencies, (function (dep) {
                            var variable = dep.dependency;
                            switch (variable.TAG | 0) {
                              case /* Direct */1 :
                                  var variable$1 = variable._0;
                                  var name = variable$1.value;
                                  if (name.TAG === /* JSON */0) {
                                    return ;
                                  }
                                  var name$1 = name._0;
                                  return Belt_Option.map(Belt_Array.getBy(Card.getFirstVariables(request.operation), (function (param) {
                                                    return param[0] === variable$1.name;
                                                  })), (function (param) {
                                                return {
                                                        upstreamName: param[0],
                                                        upstreamType: param[1],
                                                        exposedName: name$1
                                                      };
                                              }));
                              case /* ArgumentDependency */0 :
                              case /* GraphQLProbe */2 :
                                  return ;
                              
                            }
                          }));
            })));
  var match = Belt_Array.reduce(exposedVariables, [
        undefined,
        []
      ], (function (param, next) {
          var uniqueVariables = param[1];
          var names = param[0];
          if (Belt_SetString.has(names, next.exposedName)) {
            return [
                    names,
                    uniqueVariables
                  ];
          } else {
            return [
                    Belt_SetString.add(names, next.exposedName),
                    Belt_Array.concat(uniqueVariables, [next])
                  ];
          }
        }));
  var exposedVariableNamesAndTypes = match[1];
  var makeRequest = function (request) {
    var variables = Belt_Array.keepMap(request.variableDependencies, (function (dep) {
            var variable = dep.dependency;
            switch (variable.TAG | 0) {
              case /* Direct */1 :
                  var variable$1 = variable._0;
                  var json = variable$1.value;
                  if (json.TAG === /* JSON */0) {
                    return "{name: \"" + variable$1.name + "\", value: " + JSON.stringify(json._0) + "}";
                  } else {
                    return "{name: \"" + variable$1.name + "\", value: \$" + json._0 + "}";
                  }
              case /* ArgumentDependency */0 :
              case /* GraphQLProbe */2 :
                  return ;
              
            }
          }));
    var argumentDependencies = Belt_Array.keepMap(request.variableDependencies, (function (dep) {
            var dep$1 = dep.dependency;
            switch (dep$1.TAG | 0) {
              case /* ArgumentDependency */0 :
                  var dep$2 = dep$1._0;
                  var ids = Belt_Array.map(dep$2.fromRequestIds, (function (reqId) {
                            return "\"" + reqId + "\"";
                          })).join(", ");
                  var reqIds = "[" + ids + "]";
                  var fields = [
                      "name: \"" + dep$2.name + "\"",
                      "ifList: " + dep$2.ifList,
                      "ifMissing: " + dep$2.ifMissing,
                      "fromRequestIds: " + reqIds,
                      "functionFromScript: \"" + dep$2.functionFromScript + "\""
                    ].join(",\n                  ");
                  return "\n                {\n                  " + fields + "\n                }\n";
              case /* Direct */1 :
                  return ;
              case /* GraphQLProbe */2 :
                  var probe = dep$1._0;
                  var ids$1 = "\"" + probe.fromRequestId + "\"";
                  var reqIds$1 = "[" + ids$1 + "]";
                  var fields$1 = [
                      "name: \"" + probe.name + "\"",
                      "ifList: " + probe.ifList,
                      "ifMissing: " + probe.ifMissing,
                      "fromRequestIds: " + reqIds$1,
                      "functionFromScript: \"" + probe.functionFromScript + "\""
                    ].join(",\n                  ");
                  return "\n                {\n                  " + fields$1 + "\n                }\n";
              
            }
          }));
    return "\n          {\n            id: \"" + request.id + "\",\n            operationName: \"" + request.operation.title + "\",\n            variables: [" + variables.join(",\n  ") + "],\n            argumentDependencies: [" + argumentDependencies.join(",") + "],\n          }";
  };
  var requests = Belt_Array.keepMap(Belt_SortArray.stableSortBy(chain.requests, (function (a, b) {
              var match = a.operation.kind;
              var match$1 = b.operation.kind;
              if (match !== 2) {
                if (match$1 !== 2) {
                  return 0;
                } else {
                  return 1;
                }
              } else {
                return -1;
              }
            })), (function (request) {
          var match = request.operation.kind;
          if (match !== 3) {
            return makeRequest(request);
          }
          
        }));
  var scriptDependencies = Belt_Array.map(chain.scriptDependencies, (function (param) {
          return "{name: \"" + param.name + "\", version: \"" + param.version + "\"}";
        }));
  var compiledString = "requests: [" + requests.join(",") + "],\n    scriptDependencies: [" + scriptDependencies.join(",") + "],\n    script: \"\"\"\n" + chain.script + "\n\"\"\",\n  ";
  var operationVariables;
  if (exposedVariableNamesAndTypes.length !== 0) {
    var variableNames = Belt_Array.map(exposedVariableNamesAndTypes, (function (param) {
              var isRequired = param.upstreamType.endsWith("!") ? "!" : "";
              return "\$" + param.exposedName + ": JSON" + isRequired;
            })).join(",\n ");
    operationVariables = "(" + variableNames + ")";
  } else {
    operationVariables = "";
  }
  var operationName = "ExecuteChainMutation_" + chain.name;
  var base = "mutation " + operationName + operationVariables + " {\n  oneGraph {\n    executeChain(\n      input: {\n        " + compiledString + "\n      }\n    ) {\n      results {\n        request {\n          id\n        }\n        result\n        argumentDependencies {\n          name\n          returnValues\n          logs {\n            level\n            body\n          }\n          error {\n            name\n            message\n            stackString\n          }\n        }\n      }\n    }\n  }\n}";
  var operationDoc = "\n" + base + "\n\n" + blockOperations;
  return {
          operationDoc: operationDoc,
          chains: [{
              name: chain.name,
              operationName: operationName,
              exposedVariables: exposedVariables
            }]
        };
}

var docId = "localChains";

function loadFromLocalStorage(param) {
  var jsonString = localStorage.getItem(docId);
  return Belt_Option.mapWithDefault(jsonString === null ? undefined : Caml_option.some(jsonString), [], (function (jsonString) {
                return JSON.parse(jsonString);
              }));
}

function loadFromLocalStorageById(chainId) {
  return Belt_Array.getBy(loadFromLocalStorage(undefined), (function (chain) {
                return Caml_obj.caml_equal(chain.id, Caml_option.some(Uuid.parseExn(chainId)));
              }));
}

function saveToLocalStorage(chain) {
  var existingChains = loadFromLocalStorage(undefined);
  var existingChain = Belt_Array.getBy(existingChains, (function (existingChain) {
          if (Belt_Option.isSome(existingChain.id)) {
            return Caml_obj.caml_equal(existingChain.id, chain.id);
          } else {
            return false;
          }
        }));
  var newChains = existingChain !== undefined ? Belt_Array.map(existingChains, (function (oldChain) {
            if (Caml_obj.caml_equal(oldChain.id, existingChain.id)) {
              return chain;
            } else {
              return oldChain;
            }
          })) : Belt_Array.concat(existingChains, [chain]);
  var jsonString = JSON.stringify(newChains);
  localStorage.setItem(docId, jsonString);
  
}

function deleteFromLocalStorage(chain) {
  var existingChains = loadFromLocalStorage(undefined);
  var newChains = Belt_Array.keep(existingChains, (function (oldChain) {
          return Caml_obj.caml_notequal(oldChain.id, chain.id);
        }));
  var jsonString = JSON.stringify(newChains);
  localStorage.setItem(docId, jsonString);
  
}

function servicesRequired(chain) {
  return Utils.$$String.distinctStrings(Belt_Array.concatMany(Belt_Array.map(chain.requests, (function (request) {
                        return request.operation.services;
                      }))));
}

var CircularDependencyDetected = /* @__PURE__ */Caml_exceptions.create("Chain.CircularDependencyDetected");

function toposortRequests(requests) {
  var toposortHelper = function (request, visited, temp, requests, sorted) {
    if (Belt_SetString.has(visited, request.id)) {
      
    } else {
      sorted.contents = Belt_Array.concat(sorted.contents, [request]);
    }
    var deps = request.dependencyRequestIds;
    var match = Belt_Array.reduce(deps, [
          visited,
          temp
        ], (function (param, depId) {
            var temp = param[1];
            var visited = param[0];
            var alreadyVisited = Belt_SetString.has(visited, depId);
            var loopDetected = Belt_SetString.has(temp, depId);
            if (loopDetected) {
              throw {
                    RE_EXN_ID: CircularDependencyDetected,
                    Error: new Error()
                  };
            }
            if (alreadyVisited) {
              return [
                      visited,
                      temp
                    ];
            } else {
              return Belt_Option.mapWithDefault(Belt_Array.getBy(requests, (function (existingRequest) {
                                return existingRequest.id === depId;
                              })), [
                          visited,
                          temp
                        ], (function (dependencyRequest) {
                            var visited$1 = Belt_SetString.add(visited, request.id);
                            var temp$1 = Belt_SetString.add(temp, request.id);
                            return toposortHelper(dependencyRequest, visited$1, temp$1, requests, sorted);
                          }));
            }
          }));
    var visited$1 = Belt_SetString.add(match[0], request.id);
    var temp$1 = Belt_SetString.remove(match[1], request.id);
    return [
            visited$1,
            temp$1
          ];
  };
  var sorted = {
    contents: []
  };
  try {
    Belt_Array.reduce(requests, [
          undefined,
          undefined
        ], (function (param, request) {
            return toposortHelper(request, param[0], param[1], requests, sorted);
          }));
    return {
            TAG: 0,
            _0: sorted.contents,
            [Symbol.for("name")]: "Ok"
          };
  }
  catch (raw_other){
    var other = Caml_js_exceptions.internalToOCamlException(raw_other);
    if (other.RE_EXN_ID === CircularDependencyDetected) {
      return {
              TAG: 1,
              _0: "circularDependencyDetected",
              [Symbol.for("name")]: "Error"
            };
    } else {
      console.warn("Unexpected exception", other);
      return {
              TAG: 1,
              _0: "circularDependencyDetected",
              [Symbol.for("name")]: "Error"
            };
    }
  }
}

function gatherAllReferencedServices(schema, chain) {
  var requestServices = Belt_Array.concatMany(Belt_Array.map(chain.requests, (function (request) {
              var parsedOperation = Graphql.parse(request.operation.body);
              var definition = Belt_Array.getExn(parsedOperation.definitions, 0);
              return Belt_Array.map(GraphQLUtils.gatherAllReferencedServices(schema, definition), (function (service) {
                            return service.slug;
                          }));
            })));
  var blockServices = Belt_Array.concatMany(Belt_Array.map(chain.blocks, (function (block) {
              var parsedOperation = Graphql.parse(block.body);
              var definition = Belt_Array.getExn(parsedOperation.definitions, 0);
              return Belt_Array.map(GraphQLUtils.gatherAllReferencedServices(schema, definition), (function (service) {
                            return service.slug;
                          }));
            })));
  return Belt_SortArray.stableSortBy(Utils.$$String.distinctStrings(Belt_Array.concat(requestServices, blockServices)), $$String.compare);
}

var docId$1 = "localChainTraces";

function loadFromLocalStorage$1(param) {
  var jsonString = localStorage.getItem(docId$1);
  return Belt_Option.mapWithDefault(jsonString === null ? undefined : Caml_option.some(jsonString), [], (function (jsonString) {
                return JSON.parse(jsonString);
              }));
}

function saveToLocalStorage$1(trace) {
  var existingTraces = loadFromLocalStorage$1(undefined);
  var newTraces = Belt_Array.concat(existingTraces, [trace]);
  var jsonString = JSON.stringify(newTraces);
  try {
    localStorage.setItem(docId$1, jsonString);
    return ;
  }
  catch (exn){
    localStorage.removeItem(docId$1);
    localStorage.setItem(docId$1, jsonString);
    return ;
  }
}

var Trace = {
  docId: docId$1,
  loadFromLocalStorage: loadFromLocalStorage$1,
  saveToLocalStorage: saveToLocalStorage$1
};

function chainPrincipleKind(chain) {
  var match = Belt_Array.reduce(chain.requests, [
        false,
        false,
        false
      ], (function (param, request) {
          var hasSubscription = param[2];
          var hasMutation = param[1];
          var hasQuery = param[0];
          var match = request.operation.kind;
          switch (match) {
            case /* Query */0 :
                return [
                        true,
                        hasMutation,
                        hasSubscription
                      ];
            case /* Mutation */1 :
                return [
                        hasQuery,
                        true,
                        hasSubscription
                      ];
            case /* Subscription */2 :
                return [
                        hasQuery,
                        hasMutation,
                        true
                      ];
            case /* Fragment */3 :
            case /* Compute */4 :
                return [
                        hasQuery,
                        hasMutation,
                        hasSubscription
                      ];
            
          }
        }));
  if (match[2]) {
    return "subscription";
  } else if (match[1]) {
    return "mutation";
  } else if (match[0]) {
    return "query";
  } else {
    return ;
  }
}

function javaScriptFunctionName(chain) {
  var kind = chainPrincipleKind(chain);
  var match = Belt_Option.getWithDefault(kind, "query");
  var prefix = match === "mutation" ? "execute" : (
      match === "subscription" ? "subscribeTo" : "fetch"
    );
  return Utils.$$String.camelize(prefix + "_" + chain.name);
}

function makeInputTypeName(chain) {
  var fnName = javaScriptFunctionName(chain);
  return fnName + "Params";
}

function makeReturnTypeName(chain) {
  var fnName = javaScriptFunctionName(chain);
  return fnName + "Return";
}

function typeScriptDefinition(schema, chain) {
  var exposedVariables = Belt_Array.concatMany(Belt_Array.map(chain.requests, (function (request) {
              return Belt_Array.keepMap(request.variableDependencies, (function (dep) {
                            var variable = dep.dependency;
                            switch (variable.TAG | 0) {
                              case /* Direct */1 :
                                  var variable$1 = variable._0;
                                  var name = variable$1.value;
                                  if (name.TAG === /* JSON */0) {
                                    return ;
                                  }
                                  var name$1 = name._0;
                                  return Belt_Option.map(Belt_Array.getBy(Card.getFirstVariables(request.operation), (function (param) {
                                                    return param[0] === variable$1.name;
                                                  })), (function (param) {
                                                return {
                                                        upstreamName: param[0],
                                                        upstreamType: param[1],
                                                        exposedName: name$1
                                                      };
                                              }));
                              case /* ArgumentDependency */0 :
                              case /* GraphQLProbe */2 :
                                  return ;
                              
                            }
                          }));
            })));
  var inputType = Belt_Array.map(exposedVariables, (function (exposedVariable) {
              var gqlType = Graphql.typeFromAST(schema, Graphql.parseType(exposedVariable.upstreamType));
              var typeScriptType = Belt_Option.mapWithDefault(gqlType, "any", (function (gqlType) {
                      return GraphQLJs.Mock.typeScriptForGraphQLType(schema, gqlType);
                    }));
              return "\"" + exposedVariable.exposedName + "\": " + typeScriptType;
            })).join(",").replace(new RegExp(",", "g"), ",\n\t");
  var chainFragmentsDoc = Belt_Array.keepMap(chain.blocks, (function (block) {
              var match = block.kind;
              if (match !== 3) {
                return ;
              } else {
                return block.body;
              }
            })).join("\n\n").concat("\n\nfragment INTERNAL_UNUSED on Query { __typename }");
  var chainFragmentDefinitions = GraphQLJs.Mock.gatherFragmentDefinitions({
        operationDoc: chainFragmentsDoc
      });
  var returnType = Belt_Array.map(chain.requests, (function (request) {
              var block = request.operation;
              var ast = Graphql.parse(block.body);
              var definition = Caml_array.get(ast.definitions, 0);
              var typeScriptType = GraphQLJs.Mock.typeScriptForOperation(schema, definition, chainFragmentDefinitions);
              return "\"" + request.id + "\": " + typeScriptType;
            })).join(",").replace(new RegExp(",", "g"), ",\n\t");
  var inputTypeName = makeInputTypeName(chain);
  var returnTypeName = makeReturnTypeName(chain);
  var functionName = javaScriptFunctionName(chain);
  var description = Belt_Option.mapWithDefault(chain.description, "", (function (description) {
          var description$1 = description.replace(new RegExp("\n", "g"), "\n*");
          return "/**\n* " + description$1 + "\n*/";
        }));
  var fullExport = "type " + inputTypeName + " = {" + inputType + "};\n\ntype " + returnTypeName + " = {errors: Array<any>, " + returnType + "};\n\n" + description + "\nexport function " + functionName + "(input: " + inputTypeName + "): Promise<" + returnTypeName + "> {};";
  return {
          functionName: functionName,
          inputTypeName: inputTypeName,
          inputType: "{" + inputType + "}",
          returnTypeName: returnTypeName,
          returnType: "Promise<" + returnType + ">",
          fullExport: fullExport
        };
}

function requestHasComputedVariables(request) {
  return Belt_Array.some(request.variableDependencies, (function (varDep) {
                var match = varDep.dependency;
                switch (match.TAG | 0) {
                  case /* ArgumentDependency */0 :
                      return true;
                  case /* Direct */1 :
                  case /* GraphQLProbe */2 :
                      return false;
                  
                }
              }));
}

function fetchSource(schema, appId, docId, typeScriptDefinition, chain) {
  var compiled = compileOperationDoc(schema, "https://serve.onegraph.io/dev/null", chain);
  var targetChain = compiled.chains[0];
  var freeVariables = Belt_Array.map(targetChain.exposedVariables, (function (exposed) {
            var key = exposed.exposedName;
            return "\"" + key + "\": params." + key;
          })).join(", ");
  var pluckers = Belt_Array.map(chain.requests, (function (request) {
            return "const " + request.id + "Results = json?.data?.oneGraph?.executeChain?.results?.find(result => result?.request?.id === \"" + request.id + "\")?.result?.[0];";
          })).join("\n\t");
  var pluckedFields = Belt_Array.map(chain.requests, (function (request) {
            return request.id + ": " + request.id + "Results";
          })).join(",\n\t\t");
  return "export async function " + typeScriptDefinition.functionName + " (params) {\n  const resp = await fetch(\"https://serve.onegraph.com/graphql?app_id=" + appId + "\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n        body: JSON.stringify({\n        \"doc_id\": \"" + docId + "\",\n        \"operationName\": \"" + targetChain.operationName + "\",\n        \"variables\": {" + freeVariables + "}\n        }\n      )\n    }\n  )\n\n  const json = await resp.json();\n  \n  " + pluckers + "\n\n const allErrors = json?.data?.oneGraph?.executeChain?.results\n    ?.map((step) => step?.result[0].errors)\n    .flat()\n    .filter(Boolean);\n\n  return {\n    errors: [...(json?.errors || []), ...(allErrors || [])],\n    " + pluckedFields + "\n  }\n}";
}

var TypeScript = {
  fetchSource: fetchSource
};

var target = "mutation ExecuteChainMutation(\n  $webhookUrl: JSON!\n  $chain: OneGraphQueryChainInput!\n  $sheetId: JSON!\n) {\n  oneGraph {\n    executeChain(\n      input: {\n        requests: [\n          {\n            id: \"SlackReactionSubscription\"\n            operationName: \"SlackReactionSubscription\"\n            variables: [\n              { name: \"webhookUrl\", value: $webhookUrl }\n            ]\n          }\n          {\n            id: \"AddToDocMutation\"\n            operationName: \"AddToDocMutation\"\n            argumentDependencies: {\n              name: \"row\"\n              ifList: ALL\n              fromRequestIds: [\"SlackReactionSubscription\"]\n              functionFromScript: \"getRow\"\n              ifMissing: SKIP\n            }\n            variables: { name: \"sheetId\", value: $sheetId }\n          }\n        ]\n        script: \"const a = true;\"\n      }\n    ) {\n      results {\n        request {\n          id\n        }\n        result\n        argumentDependencies {\n          name\n          returnValues\n          logs {\n            level\n            body\n          }\n          name\n        }\n      }\n    }\n  }\n}\n\nmutation AddToDocMutation(\n  $sheetId: String!\n  $row: [String!]!\n) {\n  google {\n    sheets {\n      appendValues(\n        id: $sheetId\n        valueInputOption: \"USER_ENTERED\"\n        majorDimenson: \"ROWS\"\n        range: \"'Raw Data'!A1\"\n        values: [$row]\n      ) {\n        updates {\n          spreadsheetId\n          updatedRange\n          updatedCells\n          updatedData {\n            values\n          }\n        }\n      }\n    }\n  }\n}\n\nsubscription SlackReactionSubscription(\n  $webhookUrl: String!\n) {\n  slack(webhookUrl: $webhookUrl) {\n    reactionAddedEvent {\n      eventTime\n      event {\n        user {\n          id\n          name\n        }\n        eventTs\n        reaction\n        item {\n          channel {\n            name\n          }\n          message {\n            permaLink\n            user {\n              id\n              name\n            }\n            text\n            ts\n          }\n        }\n      }\n    }\n  }\n}";

var chain = emptyChain;

export {
  stringOfIfMissing ,
  ifMissingOfString ,
  stringOfIfList ,
  ifListOfString ,
  base ,
  makeChain ,
  target ,
  addToDocMutation ,
  slackSub ,
  npmDownloadsLastMonth ,
  testMutation ,
  req1 ,
  req2 ,
  req3 ,
  req4 ,
  req5 ,
  req6 ,
  chain2 ,
  _chain ,
  makeEmptyChain ,
  emptyChain ,
  chain ,
  compileAsObj ,
  requestScriptNames ,
  callForVariable ,
  callForProbe ,
  compileOperationDoc ,
  docId ,
  loadFromLocalStorage ,
  loadFromLocalStorageById ,
  saveToLocalStorage ,
  deleteFromLocalStorage ,
  servicesRequired ,
  CircularDependencyDetected ,
  toposortRequests ,
  gatherAllReferencedServices ,
  Trace ,
  chainPrincipleKind ,
  javaScriptFunctionName ,
  makeInputTypeName ,
  makeReturnTypeName ,
  typeScriptDefinition ,
  requestHasComputedVariables ,
  TypeScript ,
  
}
/* addToDocMutation Not a pure module */
